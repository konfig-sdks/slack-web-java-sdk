/*
 * Slack Web API
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.7.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ConversationsArchiveRequest;
import com.konfigthis.client.model.ConversationsArchiveResponse;
import com.konfigthis.client.model.ConversationsArchivedefaultResponse;
import com.konfigthis.client.model.ConversationsCloseRequest;
import com.konfigthis.client.model.ConversationsCloseResponse;
import com.konfigthis.client.model.ConversationsClosedefaultResponse;
import com.konfigthis.client.model.ConversationsCreateRequest;
import com.konfigthis.client.model.ConversationsCreateResponse;
import com.konfigthis.client.model.ConversationsCreatedefaultResponse;
import com.konfigthis.client.model.ConversationsHistoryResponse;
import com.konfigthis.client.model.ConversationsHistorydefaultResponse;
import com.konfigthis.client.model.ConversationsInfoResponse;
import com.konfigthis.client.model.ConversationsInfodefaultResponse;
import com.konfigthis.client.model.ConversationsInviteRequest;
import com.konfigthis.client.model.ConversationsInviteResponse;
import com.konfigthis.client.model.ConversationsInvitedefaultResponse;
import com.konfigthis.client.model.ConversationsJoinRequest;
import com.konfigthis.client.model.ConversationsJoinResponse;
import com.konfigthis.client.model.ConversationsJoindefaultResponse;
import com.konfigthis.client.model.ConversationsKickRequest;
import com.konfigthis.client.model.ConversationsKickResponse;
import com.konfigthis.client.model.ConversationsKickdefaultResponse;
import com.konfigthis.client.model.ConversationsLeaveRequest;
import com.konfigthis.client.model.ConversationsLeaveResponse;
import com.konfigthis.client.model.ConversationsLeavedefaultResponse;
import com.konfigthis.client.model.ConversationsListResponse;
import com.konfigthis.client.model.ConversationsListdefaultResponse;
import com.konfigthis.client.model.ConversationsMarkRequest;
import com.konfigthis.client.model.ConversationsMarkResponse;
import com.konfigthis.client.model.ConversationsMarkdefaultResponse;
import com.konfigthis.client.model.ConversationsMembersResponse;
import com.konfigthis.client.model.ConversationsMembersdefaultResponse;
import com.konfigthis.client.model.ConversationsOpenRequest;
import com.konfigthis.client.model.ConversationsOpenResponse;
import com.konfigthis.client.model.ConversationsOpendefaultResponse;
import com.konfigthis.client.model.ConversationsRenameRequest;
import com.konfigthis.client.model.ConversationsRenameResponse;
import com.konfigthis.client.model.ConversationsRenamedefaultResponse;
import com.konfigthis.client.model.ConversationsRepliesResponse;
import com.konfigthis.client.model.ConversationsRepliesdefaultResponse;
import com.konfigthis.client.model.ConversationsSetPurposeRequest;
import com.konfigthis.client.model.ConversationsSetPurposeResponse;
import com.konfigthis.client.model.ConversationsSetPurposedefaultResponse;
import com.konfigthis.client.model.ConversationsSetTopicRequest;
import com.konfigthis.client.model.ConversationsSetTopicResponse;
import com.konfigthis.client.model.ConversationsSetTopicdefaultResponse;
import com.konfigthis.client.model.ConversationsUnarchiveRequest;
import com.konfigthis.client.model.ConversationsUnarchiveResponse;
import com.konfigthis.client.model.ConversationsUnarchivedefaultResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class ConversationsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ConversationsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public ConversationsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call archiveCall(String token, String channel, ConversationsArchiveRequest conversationsArchiveRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsArchiveRequest;

        // create path and map variables
        String localVarPath = "/conversations.archive";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call archiveValidateBeforeCall(String token, String channel, ConversationsArchiveRequest conversationsArchiveRequest, final ApiCallback _callback) throws ApiException {
        return archiveCall(token, channel, conversationsArchiveRequest, _callback);

    }


    private ApiResponse<ConversationsArchiveResponse> archiveWithHttpInfo(String token, String channel, ConversationsArchiveRequest conversationsArchiveRequest) throws ApiException {
        okhttp3.Call localVarCall = archiveValidateBeforeCall(token, channel, conversationsArchiveRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsArchiveResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call archiveAsync(String token, String channel, ConversationsArchiveRequest conversationsArchiveRequest, final ApiCallback<ConversationsArchiveResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = archiveValidateBeforeCall(token, channel, conversationsArchiveRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsArchiveResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ArchiveRequestBuilder {
        private String token;
        private String channel;

        private ArchiveRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return ArchiveRequestBuilder
         */
        public ArchiveRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel ID of conversation to archive (optional)
         * @return ArchiveRequestBuilder
         */
        public ArchiveRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Build call for archive
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsArchiveRequest conversationsArchiveRequest = buildBodyParams();
            return archiveCall(token, channel, conversationsArchiveRequest, _callback);
        }

        private ConversationsArchiveRequest buildBodyParams() {
            ConversationsArchiveRequest conversationsArchiveRequest = new ConversationsArchiveRequest();
            conversationsArchiveRequest.channel(this.channel);
            return conversationsArchiveRequest;
        }

        /**
         * Execute archive request
         * @return ConversationsArchiveResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsArchiveResponse execute() throws ApiException {
            ConversationsArchiveRequest conversationsArchiveRequest = buildBodyParams();
            ApiResponse<ConversationsArchiveResponse> localVarResp = archiveWithHttpInfo(token, channel, conversationsArchiveRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute archive request with HTTP info returned
         * @return ApiResponse&lt;ConversationsArchiveResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsArchiveResponse> executeWithHttpInfo() throws ApiException {
            ConversationsArchiveRequest conversationsArchiveRequest = buildBodyParams();
            return archiveWithHttpInfo(token, channel, conversationsArchiveRequest);
        }

        /**
         * Execute archive request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsArchiveResponse> _callback) throws ApiException {
            ConversationsArchiveRequest conversationsArchiveRequest = buildBodyParams();
            return archiveAsync(token, channel, conversationsArchiveRequest, _callback);
        }
    }

    /**
     * 
     * Archives a conversation.
     * @return ArchiveRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.archive"> Documentation</a>
     */
    public ArchiveRequestBuilder archive() throws IllegalArgumentException {
        return new ArchiveRequestBuilder();
    }
    private okhttp3.Call closeCall(String token, String channel, ConversationsCloseRequest conversationsCloseRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsCloseRequest;

        // create path and map variables
        String localVarPath = "/conversations.close";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call closeValidateBeforeCall(String token, String channel, ConversationsCloseRequest conversationsCloseRequest, final ApiCallback _callback) throws ApiException {
        return closeCall(token, channel, conversationsCloseRequest, _callback);

    }


    private ApiResponse<ConversationsCloseResponse> closeWithHttpInfo(String token, String channel, ConversationsCloseRequest conversationsCloseRequest) throws ApiException {
        okhttp3.Call localVarCall = closeValidateBeforeCall(token, channel, conversationsCloseRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsCloseResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call closeAsync(String token, String channel, ConversationsCloseRequest conversationsCloseRequest, final ApiCallback<ConversationsCloseResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = closeValidateBeforeCall(token, channel, conversationsCloseRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsCloseResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CloseRequestBuilder {
        private String token;
        private String channel;

        private CloseRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return CloseRequestBuilder
         */
        public CloseRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Conversation to close. (optional)
         * @return CloseRequestBuilder
         */
        public CloseRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Build call for close
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsCloseRequest conversationsCloseRequest = buildBodyParams();
            return closeCall(token, channel, conversationsCloseRequest, _callback);
        }

        private ConversationsCloseRequest buildBodyParams() {
            ConversationsCloseRequest conversationsCloseRequest = new ConversationsCloseRequest();
            conversationsCloseRequest.channel(this.channel);
            return conversationsCloseRequest;
        }

        /**
         * Execute close request
         * @return ConversationsCloseResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsCloseResponse execute() throws ApiException {
            ConversationsCloseRequest conversationsCloseRequest = buildBodyParams();
            ApiResponse<ConversationsCloseResponse> localVarResp = closeWithHttpInfo(token, channel, conversationsCloseRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute close request with HTTP info returned
         * @return ApiResponse&lt;ConversationsCloseResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsCloseResponse> executeWithHttpInfo() throws ApiException {
            ConversationsCloseRequest conversationsCloseRequest = buildBodyParams();
            return closeWithHttpInfo(token, channel, conversationsCloseRequest);
        }

        /**
         * Execute close request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsCloseResponse> _callback) throws ApiException {
            ConversationsCloseRequest conversationsCloseRequest = buildBodyParams();
            return closeAsync(token, channel, conversationsCloseRequest, _callback);
        }
    }

    /**
     * 
     * Closes a direct message or multi-person direct message.
     * @return CloseRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.close"> Documentation</a>
     */
    public CloseRequestBuilder close() throws IllegalArgumentException {
        return new CloseRequestBuilder();
    }
    private okhttp3.Call createCall(String token, Boolean isPrivate, String name, ConversationsCreateRequest conversationsCreateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsCreateRequest;

        // create path and map variables
        String localVarPath = "/conversations.create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (isPrivate != null) {
            localVarFormParams.put("is_private", isPrivate);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createValidateBeforeCall(String token, Boolean isPrivate, String name, ConversationsCreateRequest conversationsCreateRequest, final ApiCallback _callback) throws ApiException {
        return createCall(token, isPrivate, name, conversationsCreateRequest, _callback);

    }


    private ApiResponse<ConversationsCreateResponse> createWithHttpInfo(String token, Boolean isPrivate, String name, ConversationsCreateRequest conversationsCreateRequest) throws ApiException {
        okhttp3.Call localVarCall = createValidateBeforeCall(token, isPrivate, name, conversationsCreateRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsCreateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call createAsync(String token, Boolean isPrivate, String name, ConversationsCreateRequest conversationsCreateRequest, final ApiCallback<ConversationsCreateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createValidateBeforeCall(token, isPrivate, name, conversationsCreateRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsCreateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class CreateRequestBuilder {
        private String token;
        private Boolean isPrivate;
        private String name;

        private CreateRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set isPrivate
         * @param isPrivate Create a private channel instead of a public one (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder isPrivate(Boolean isPrivate) {
            this.isPrivate = isPrivate;
            return this;
        }
        
        /**
         * Set name
         * @param name Name of the public or private channel to create (optional)
         * @return CreateRequestBuilder
         */
        public CreateRequestBuilder name(String name) {
            this.name = name;
            return this;
        }
        
        /**
         * Build call for create
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> If successful, the command returns a rather stark [conversation object](https://slack.dev) </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when name already in use </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsCreateRequest conversationsCreateRequest = buildBodyParams();
            return createCall(token, isPrivate, name, conversationsCreateRequest, _callback);
        }

        private ConversationsCreateRequest buildBodyParams() {
            ConversationsCreateRequest conversationsCreateRequest = new ConversationsCreateRequest();
            conversationsCreateRequest.isPrivate(this.isPrivate);
            conversationsCreateRequest.name(this.name);
            return conversationsCreateRequest;
        }

        /**
         * Execute create request
         * @return ConversationsCreateResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> If successful, the command returns a rather stark [conversation object](https://slack.dev) </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when name already in use </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsCreateResponse execute() throws ApiException {
            ConversationsCreateRequest conversationsCreateRequest = buildBodyParams();
            ApiResponse<ConversationsCreateResponse> localVarResp = createWithHttpInfo(token, isPrivate, name, conversationsCreateRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute create request with HTTP info returned
         * @return ApiResponse&lt;ConversationsCreateResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> If successful, the command returns a rather stark [conversation object](https://slack.dev) </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when name already in use </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsCreateResponse> executeWithHttpInfo() throws ApiException {
            ConversationsCreateRequest conversationsCreateRequest = buildBodyParams();
            return createWithHttpInfo(token, isPrivate, name, conversationsCreateRequest);
        }

        /**
         * Execute create request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> If successful, the command returns a rather stark [conversation object](https://slack.dev) </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when name already in use </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsCreateResponse> _callback) throws ApiException {
            ConversationsCreateRequest conversationsCreateRequest = buildBodyParams();
            return createAsync(token, isPrivate, name, conversationsCreateRequest, _callback);
        }
    }

    /**
     * 
     * Initiates a public or private channel-based conversation
     * @return CreateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> If successful, the command returns a rather stark [conversation object](https://slack.dev) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when name already in use </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.create"> Documentation</a>
     */
    public CreateRequestBuilder create() throws IllegalArgumentException {
        return new CreateRequestBuilder();
    }
    private okhttp3.Call historyCall(String token, String channel, Double latest, Double oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (latest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latest", latest));
        }

        if (oldest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oldest", oldest));
        }

        if (inclusive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inclusive", inclusive));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call historyValidateBeforeCall(String token, String channel, Double latest, Double oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        return historyCall(token, channel, latest, oldest, inclusive, limit, cursor, _callback);

    }


    private ApiResponse<ConversationsHistoryResponse> historyWithHttpInfo(String token, String channel, Double latest, Double oldest, Boolean inclusive, Integer limit, String cursor) throws ApiException {
        okhttp3.Call localVarCall = historyValidateBeforeCall(token, channel, latest, oldest, inclusive, limit, cursor, null);
        Type localVarReturnType = new TypeToken<ConversationsHistoryResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call historyAsync(String token, String channel, Double latest, Double oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback<ConversationsHistoryResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = historyValidateBeforeCall(token, channel, latest, oldest, inclusive, limit, cursor, _callback);
        Type localVarReturnType = new TypeToken<ConversationsHistoryResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class HistoryRequestBuilder {
        private String token;
        private String channel;
        private Double latest;
        private Double oldest;
        private Boolean inclusive;
        private Integer limit;
        private String cursor;

        private HistoryRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
         * @return HistoryRequestBuilder
         */
        public HistoryRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Conversation ID to fetch history for. (optional)
         * @return HistoryRequestBuilder
         */
        public HistoryRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set latest
         * @param latest End of time range of messages to include in results. (optional)
         * @return HistoryRequestBuilder
         */
        public HistoryRequestBuilder latest(Double latest) {
            this.latest = latest;
            return this;
        }
        
        /**
         * Set oldest
         * @param oldest Start of time range of messages to include in results. (optional)
         * @return HistoryRequestBuilder
         */
        public HistoryRequestBuilder oldest(Double oldest) {
            this.oldest = oldest;
            return this;
        }
        
        /**
         * Set inclusive
         * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
         * @return HistoryRequestBuilder
         */
        public HistoryRequestBuilder inclusive(Boolean inclusive) {
            this.inclusive = inclusive;
            return this;
        }
        
        /**
         * Set limit
         * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
         * @return HistoryRequestBuilder
         */
        public HistoryRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set cursor
         * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail. (optional)
         * @return HistoryRequestBuilder
         */
        public HistoryRequestBuilder cursor(String cursor) {
            this.cursor = cursor;
            return this;
        }
        
        /**
         * Build call for history
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response containing a channel&#39;s messages </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return historyCall(token, channel, latest, oldest, inclusive, limit, cursor, _callback);
        }


        /**
         * Execute history request
         * @return ConversationsHistoryResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response containing a channel&#39;s messages </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsHistoryResponse execute() throws ApiException {
            ApiResponse<ConversationsHistoryResponse> localVarResp = historyWithHttpInfo(token, channel, latest, oldest, inclusive, limit, cursor);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute history request with HTTP info returned
         * @return ApiResponse&lt;ConversationsHistoryResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response containing a channel&#39;s messages </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsHistoryResponse> executeWithHttpInfo() throws ApiException {
            return historyWithHttpInfo(token, channel, latest, oldest, inclusive, limit, cursor);
        }

        /**
         * Execute history request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response containing a channel&#39;s messages </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsHistoryResponse> _callback) throws ApiException {
            return historyAsync(token, channel, latest, oldest, inclusive, limit, cursor, _callback);
        }
    }

    /**
     * 
     * Fetches a conversation&#39;s history of messages and events.
     * @return HistoryRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response containing a channel&#39;s messages </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.history"> Documentation</a>
     */
    public HistoryRequestBuilder history() throws IllegalArgumentException {
        return new HistoryRequestBuilder();
    }
    private okhttp3.Call infoCall(String token, String channel, Boolean includeLocale, Boolean includeNumMembers, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.info";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (includeLocale != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_locale", includeLocale));
        }

        if (includeNumMembers != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_num_members", includeNumMembers));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call infoValidateBeforeCall(String token, String channel, Boolean includeLocale, Boolean includeNumMembers, final ApiCallback _callback) throws ApiException {
        return infoCall(token, channel, includeLocale, includeNumMembers, _callback);

    }


    private ApiResponse<ConversationsInfoResponse> infoWithHttpInfo(String token, String channel, Boolean includeLocale, Boolean includeNumMembers) throws ApiException {
        okhttp3.Call localVarCall = infoValidateBeforeCall(token, channel, includeLocale, includeNumMembers, null);
        Type localVarReturnType = new TypeToken<ConversationsInfoResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call infoAsync(String token, String channel, Boolean includeLocale, Boolean includeNumMembers, final ApiCallback<ConversationsInfoResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = infoValidateBeforeCall(token, channel, includeLocale, includeNumMembers, _callback);
        Type localVarReturnType = new TypeToken<ConversationsInfoResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class InfoRequestBuilder {
        private String token;
        private String channel;
        private Boolean includeLocale;
        private Boolean includeNumMembers;

        private InfoRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
         * @return InfoRequestBuilder
         */
        public InfoRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Conversation ID to learn more about (optional)
         * @return InfoRequestBuilder
         */
        public InfoRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set includeLocale
         * @param includeLocale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60; (optional)
         * @return InfoRequestBuilder
         */
        public InfoRequestBuilder includeLocale(Boolean includeLocale) {
            this.includeLocale = includeLocale;
            return this;
        }
        
        /**
         * Set includeNumMembers
         * @param includeNumMembers Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60; (optional)
         * @return InfoRequestBuilder
         */
        public InfoRequestBuilder includeNumMembers(Boolean includeNumMembers) {
            this.includeNumMembers = includeNumMembers;
            return this;
        }
        
        /**
         * Build call for info
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response for a public channel. (Also, a response from a private channel and a multi-party IM is very similar to this example.) </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when a channel cannot be found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return infoCall(token, channel, includeLocale, includeNumMembers, _callback);
        }


        /**
         * Execute info request
         * @return ConversationsInfoResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response for a public channel. (Also, a response from a private channel and a multi-party IM is very similar to this example.) </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when a channel cannot be found </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsInfoResponse execute() throws ApiException {
            ApiResponse<ConversationsInfoResponse> localVarResp = infoWithHttpInfo(token, channel, includeLocale, includeNumMembers);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute info request with HTTP info returned
         * @return ApiResponse&lt;ConversationsInfoResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response for a public channel. (Also, a response from a private channel and a multi-party IM is very similar to this example.) </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when a channel cannot be found </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsInfoResponse> executeWithHttpInfo() throws ApiException {
            return infoWithHttpInfo(token, channel, includeLocale, includeNumMembers);
        }

        /**
         * Execute info request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response for a public channel. (Also, a response from a private channel and a multi-party IM is very similar to this example.) </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when a channel cannot be found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsInfoResponse> _callback) throws ApiException {
            return infoAsync(token, channel, includeLocale, includeNumMembers, _callback);
        }
    }

    /**
     * 
     * Retrieve information about a conversation.
     * @return InfoRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response for a public channel. (Also, a response from a private channel and a multi-party IM is very similar to this example.) </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when a channel cannot be found </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.info"> Documentation</a>
     */
    public InfoRequestBuilder info() throws IllegalArgumentException {
        return new InfoRequestBuilder();
    }
    private okhttp3.Call inviteCall(String token, String channel, String users, ConversationsInviteRequest conversationsInviteRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsInviteRequest;

        // create path and map variables
        String localVarPath = "/conversations.invite";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (users != null) {
            localVarFormParams.put("users", users);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call inviteValidateBeforeCall(String token, String channel, String users, ConversationsInviteRequest conversationsInviteRequest, final ApiCallback _callback) throws ApiException {
        return inviteCall(token, channel, users, conversationsInviteRequest, _callback);

    }


    private ApiResponse<ConversationsInviteResponse> inviteWithHttpInfo(String token, String channel, String users, ConversationsInviteRequest conversationsInviteRequest) throws ApiException {
        okhttp3.Call localVarCall = inviteValidateBeforeCall(token, channel, users, conversationsInviteRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsInviteResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call inviteAsync(String token, String channel, String users, ConversationsInviteRequest conversationsInviteRequest, final ApiCallback<ConversationsInviteResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = inviteValidateBeforeCall(token, channel, users, conversationsInviteRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsInviteResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class InviteRequestBuilder {
        private String token;
        private String channel;
        private String users;

        private InviteRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return InviteRequestBuilder
         */
        public InviteRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel The ID of the public or private channel to invite user(s) to. (optional)
         * @return InviteRequestBuilder
         */
        public InviteRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set users
         * @param users A comma separated list of user IDs. Up to 1000 users may be listed. (optional)
         * @return InviteRequestBuilder
         */
        public InviteRequestBuilder users(String users) {
            this.users = users;
            return this;
        }
        
        /**
         * Build call for invite
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response when an invitation is extended </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when an invite is attempted on a conversation type that does not support it </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsInviteRequest conversationsInviteRequest = buildBodyParams();
            return inviteCall(token, channel, users, conversationsInviteRequest, _callback);
        }

        private ConversationsInviteRequest buildBodyParams() {
            ConversationsInviteRequest conversationsInviteRequest = new ConversationsInviteRequest();
            conversationsInviteRequest.channel(this.channel);
            conversationsInviteRequest.users(this.users);
            return conversationsInviteRequest;
        }

        /**
         * Execute invite request
         * @return ConversationsInviteResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response when an invitation is extended </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when an invite is attempted on a conversation type that does not support it </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsInviteResponse execute() throws ApiException {
            ConversationsInviteRequest conversationsInviteRequest = buildBodyParams();
            ApiResponse<ConversationsInviteResponse> localVarResp = inviteWithHttpInfo(token, channel, users, conversationsInviteRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute invite request with HTTP info returned
         * @return ApiResponse&lt;ConversationsInviteResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response when an invitation is extended </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when an invite is attempted on a conversation type that does not support it </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsInviteResponse> executeWithHttpInfo() throws ApiException {
            ConversationsInviteRequest conversationsInviteRequest = buildBodyParams();
            return inviteWithHttpInfo(token, channel, users, conversationsInviteRequest);
        }

        /**
         * Execute invite request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response when an invitation is extended </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when an invite is attempted on a conversation type that does not support it </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsInviteResponse> _callback) throws ApiException {
            ConversationsInviteRequest conversationsInviteRequest = buildBodyParams();
            return inviteAsync(token, channel, users, conversationsInviteRequest, _callback);
        }
    }

    /**
     * 
     * Invites users to a channel.
     * @return InviteRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response when an invitation is extended </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invite is attempted on a conversation type that does not support it </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.invite"> Documentation</a>
     */
    public InviteRequestBuilder invite() throws IllegalArgumentException {
        return new InviteRequestBuilder();
    }
    private okhttp3.Call joinCall(String token, String channel, ConversationsJoinRequest conversationsJoinRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsJoinRequest;

        // create path and map variables
        String localVarPath = "/conversations.join";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call joinValidateBeforeCall(String token, String channel, ConversationsJoinRequest conversationsJoinRequest, final ApiCallback _callback) throws ApiException {
        return joinCall(token, channel, conversationsJoinRequest, _callback);

    }


    private ApiResponse<ConversationsJoinResponse> joinWithHttpInfo(String token, String channel, ConversationsJoinRequest conversationsJoinRequest) throws ApiException {
        okhttp3.Call localVarCall = joinValidateBeforeCall(token, channel, conversationsJoinRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsJoinResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call joinAsync(String token, String channel, ConversationsJoinRequest conversationsJoinRequest, final ApiCallback<ConversationsJoinResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = joinValidateBeforeCall(token, channel, conversationsJoinRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsJoinResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class JoinRequestBuilder {
        private String token;
        private String channel;

        private JoinRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;channels:write&#x60; (optional)
         * @return JoinRequestBuilder
         */
        public JoinRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel ID of conversation to join (optional)
         * @return JoinRequestBuilder
         */
        public JoinRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Build call for join
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the conversation is archived and cannot be joined </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsJoinRequest conversationsJoinRequest = buildBodyParams();
            return joinCall(token, channel, conversationsJoinRequest, _callback);
        }

        private ConversationsJoinRequest buildBodyParams() {
            ConversationsJoinRequest conversationsJoinRequest = new ConversationsJoinRequest();
            conversationsJoinRequest.channel(this.channel);
            return conversationsJoinRequest;
        }

        /**
         * Execute join request
         * @return ConversationsJoinResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the conversation is archived and cannot be joined </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsJoinResponse execute() throws ApiException {
            ConversationsJoinRequest conversationsJoinRequest = buildBodyParams();
            ApiResponse<ConversationsJoinResponse> localVarResp = joinWithHttpInfo(token, channel, conversationsJoinRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute join request with HTTP info returned
         * @return ApiResponse&lt;ConversationsJoinResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the conversation is archived and cannot be joined </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsJoinResponse> executeWithHttpInfo() throws ApiException {
            ConversationsJoinRequest conversationsJoinRequest = buildBodyParams();
            return joinWithHttpInfo(token, channel, conversationsJoinRequest);
        }

        /**
         * Execute join request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the conversation is archived and cannot be joined </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsJoinResponse> _callback) throws ApiException {
            ConversationsJoinRequest conversationsJoinRequest = buildBodyParams();
            return joinAsync(token, channel, conversationsJoinRequest, _callback);
        }
    }

    /**
     * 
     * Joins an existing conversation.
     * @return JoinRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response if the conversation is archived and cannot be joined </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.join"> Documentation</a>
     */
    public JoinRequestBuilder join() throws IllegalArgumentException {
        return new JoinRequestBuilder();
    }
    private okhttp3.Call kickCall(String token, String channel, String user, ConversationsKickRequest conversationsKickRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsKickRequest;

        // create path and map variables
        String localVarPath = "/conversations.kick";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (user != null) {
            localVarFormParams.put("user", user);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call kickValidateBeforeCall(String token, String channel, String user, ConversationsKickRequest conversationsKickRequest, final ApiCallback _callback) throws ApiException {
        return kickCall(token, channel, user, conversationsKickRequest, _callback);

    }


    private ApiResponse<ConversationsKickResponse> kickWithHttpInfo(String token, String channel, String user, ConversationsKickRequest conversationsKickRequest) throws ApiException {
        okhttp3.Call localVarCall = kickValidateBeforeCall(token, channel, user, conversationsKickRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsKickResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call kickAsync(String token, String channel, String user, ConversationsKickRequest conversationsKickRequest, final ApiCallback<ConversationsKickResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = kickValidateBeforeCall(token, channel, user, conversationsKickRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsKickResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class KickRequestBuilder {
        private String token;
        private String channel;
        private String user;

        private KickRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return KickRequestBuilder
         */
        public KickRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel ID of conversation to remove user from. (optional)
         * @return KickRequestBuilder
         */
        public KickRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set user
         * @param user User ID to be removed. (optional)
         * @return KickRequestBuilder
         */
        public KickRequestBuilder user(String user) {
            this.user = user;
            return this;
        }
        
        /**
         * Build call for kick
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when you attempt to kick yourself from a channel </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsKickRequest conversationsKickRequest = buildBodyParams();
            return kickCall(token, channel, user, conversationsKickRequest, _callback);
        }

        private ConversationsKickRequest buildBodyParams() {
            ConversationsKickRequest conversationsKickRequest = new ConversationsKickRequest();
            conversationsKickRequest.channel(this.channel);
            conversationsKickRequest.user(this.user);
            return conversationsKickRequest;
        }

        /**
         * Execute kick request
         * @return ConversationsKickResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when you attempt to kick yourself from a channel </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsKickResponse execute() throws ApiException {
            ConversationsKickRequest conversationsKickRequest = buildBodyParams();
            ApiResponse<ConversationsKickResponse> localVarResp = kickWithHttpInfo(token, channel, user, conversationsKickRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute kick request with HTTP info returned
         * @return ApiResponse&lt;ConversationsKickResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when you attempt to kick yourself from a channel </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsKickResponse> executeWithHttpInfo() throws ApiException {
            ConversationsKickRequest conversationsKickRequest = buildBodyParams();
            return kickWithHttpInfo(token, channel, user, conversationsKickRequest);
        }

        /**
         * Execute kick request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when you attempt to kick yourself from a channel </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsKickResponse> _callback) throws ApiException {
            ConversationsKickRequest conversationsKickRequest = buildBodyParams();
            return kickAsync(token, channel, user, conversationsKickRequest, _callback);
        }
    }

    /**
     * 
     * Removes a user from a conversation.
     * @return KickRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when you attempt to kick yourself from a channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.kick"> Documentation</a>
     */
    public KickRequestBuilder kick() throws IllegalArgumentException {
        return new KickRequestBuilder();
    }
    private okhttp3.Call leaveCall(String token, String channel, ConversationsLeaveRequest conversationsLeaveRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsLeaveRequest;

        // create path and map variables
        String localVarPath = "/conversations.leave";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call leaveValidateBeforeCall(String token, String channel, ConversationsLeaveRequest conversationsLeaveRequest, final ApiCallback _callback) throws ApiException {
        return leaveCall(token, channel, conversationsLeaveRequest, _callback);

    }


    private ApiResponse<ConversationsLeaveResponse> leaveWithHttpInfo(String token, String channel, ConversationsLeaveRequest conversationsLeaveRequest) throws ApiException {
        okhttp3.Call localVarCall = leaveValidateBeforeCall(token, channel, conversationsLeaveRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsLeaveResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call leaveAsync(String token, String channel, ConversationsLeaveRequest conversationsLeaveRequest, final ApiCallback<ConversationsLeaveResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = leaveValidateBeforeCall(token, channel, conversationsLeaveRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsLeaveResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class LeaveRequestBuilder {
        private String token;
        private String channel;

        private LeaveRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return LeaveRequestBuilder
         */
        public LeaveRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Conversation to leave (optional)
         * @return LeaveRequestBuilder
         */
        public LeaveRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Build call for leave
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when attempting to leave a workspace&#39;s \&quot;general\&quot; channel </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsLeaveRequest conversationsLeaveRequest = buildBodyParams();
            return leaveCall(token, channel, conversationsLeaveRequest, _callback);
        }

        private ConversationsLeaveRequest buildBodyParams() {
            ConversationsLeaveRequest conversationsLeaveRequest = new ConversationsLeaveRequest();
            conversationsLeaveRequest.channel(this.channel);
            return conversationsLeaveRequest;
        }

        /**
         * Execute leave request
         * @return ConversationsLeaveResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when attempting to leave a workspace&#39;s \&quot;general\&quot; channel </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsLeaveResponse execute() throws ApiException {
            ConversationsLeaveRequest conversationsLeaveRequest = buildBodyParams();
            ApiResponse<ConversationsLeaveResponse> localVarResp = leaveWithHttpInfo(token, channel, conversationsLeaveRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute leave request with HTTP info returned
         * @return ApiResponse&lt;ConversationsLeaveResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when attempting to leave a workspace&#39;s \&quot;general\&quot; channel </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsLeaveResponse> executeWithHttpInfo() throws ApiException {
            ConversationsLeaveRequest conversationsLeaveRequest = buildBodyParams();
            return leaveWithHttpInfo(token, channel, conversationsLeaveRequest);
        }

        /**
         * Execute leave request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when attempting to leave a workspace&#39;s \&quot;general\&quot; channel </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsLeaveResponse> _callback) throws ApiException {
            ConversationsLeaveRequest conversationsLeaveRequest = buildBodyParams();
            return leaveAsync(token, channel, conversationsLeaveRequest, _callback);
        }
    }

    /**
     * 
     * Leaves a conversation.
     * @return LeaveRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when attempting to leave a workspace&#39;s \&quot;general\&quot; channel </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.leave"> Documentation</a>
     */
    public LeaveRequestBuilder leave() throws IllegalArgumentException {
        return new LeaveRequestBuilder();
    }
    private okhttp3.Call listCall(String token, Boolean excludeArchived, String types, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (excludeArchived != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exclude_archived", excludeArchived));
        }

        if (types != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("types", types));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listValidateBeforeCall(String token, Boolean excludeArchived, String types, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        return listCall(token, excludeArchived, types, limit, cursor, _callback);

    }


    private ApiResponse<ConversationsListResponse> listWithHttpInfo(String token, Boolean excludeArchived, String types, Integer limit, String cursor) throws ApiException {
        okhttp3.Call localVarCall = listValidateBeforeCall(token, excludeArchived, types, limit, cursor, null);
        Type localVarReturnType = new TypeToken<ConversationsListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAsync(String token, Boolean excludeArchived, String types, Integer limit, String cursor, final ApiCallback<ConversationsListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listValidateBeforeCall(token, excludeArchived, types, limit, cursor, _callback);
        Type localVarReturnType = new TypeToken<ConversationsListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListRequestBuilder {
        private String token;
        private Boolean excludeArchived;
        private String types;
        private Integer limit;
        private String cursor;

        private ListRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set excludeArchived
         * @param excludeArchived Set to &#x60;true&#x60; to exclude archived channels from the list (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder excludeArchived(Boolean excludeArchived) {
            this.excludeArchived = excludeArchived;
            return this;
        }
        
        /**
         * Set types
         * @param types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60; (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder types(String types) {
            this.types = types;
            return this;
        }
        
        /**
         * Set limit
         * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set cursor
         * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder cursor(String cursor) {
            this.cursor = cursor;
            return this;
        }
        
        /**
         * Build call for list
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response with only public channels </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listCall(token, excludeArchived, types, limit, cursor, _callback);
        }


        /**
         * Execute list request
         * @return ConversationsListResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response with only public channels </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsListResponse execute() throws ApiException {
            ApiResponse<ConversationsListResponse> localVarResp = listWithHttpInfo(token, excludeArchived, types, limit, cursor);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute list request with HTTP info returned
         * @return ApiResponse&lt;ConversationsListResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response with only public channels </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsListResponse> executeWithHttpInfo() throws ApiException {
            return listWithHttpInfo(token, excludeArchived, types, limit, cursor);
        }

        /**
         * Execute list request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response with only public channels </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsListResponse> _callback) throws ApiException {
            return listAsync(token, excludeArchived, types, limit, cursor, _callback);
        }
    }

    /**
     * 
     * Lists all channels in a Slack team.
     * @return ListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response with only public channels </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.list"> Documentation</a>
     */
    public ListRequestBuilder list() throws IllegalArgumentException {
        return new ListRequestBuilder();
    }
    private okhttp3.Call markCall(String token, String channel, Double ts, ConversationsMarkRequest conversationsMarkRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsMarkRequest;

        // create path and map variables
        String localVarPath = "/conversations.mark";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (ts != null) {
            localVarFormParams.put("ts", ts);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call markValidateBeforeCall(String token, String channel, Double ts, ConversationsMarkRequest conversationsMarkRequest, final ApiCallback _callback) throws ApiException {
        return markCall(token, channel, ts, conversationsMarkRequest, _callback);

    }


    private ApiResponse<ConversationsMarkResponse> markWithHttpInfo(String token, String channel, Double ts, ConversationsMarkRequest conversationsMarkRequest) throws ApiException {
        okhttp3.Call localVarCall = markValidateBeforeCall(token, channel, ts, conversationsMarkRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsMarkResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call markAsync(String token, String channel, Double ts, ConversationsMarkRequest conversationsMarkRequest, final ApiCallback<ConversationsMarkResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = markValidateBeforeCall(token, channel, ts, conversationsMarkRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsMarkResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class MarkRequestBuilder {
        private String token;
        private String channel;
        private Double ts;

        private MarkRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return MarkRequestBuilder
         */
        public MarkRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Channel or conversation to set the read cursor for. (optional)
         * @return MarkRequestBuilder
         */
        public MarkRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set ts
         * @param ts Unique identifier of message you want marked as most recently seen in this conversation. (optional)
         * @return MarkRequestBuilder
         */
        public MarkRequestBuilder ts(Double ts) {
            this.ts = ts;
            return this;
        }
        
        /**
         * Build call for mark
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsMarkRequest conversationsMarkRequest = buildBodyParams();
            return markCall(token, channel, ts, conversationsMarkRequest, _callback);
        }

        private ConversationsMarkRequest buildBodyParams() {
            ConversationsMarkRequest conversationsMarkRequest = new ConversationsMarkRequest();
            conversationsMarkRequest.channel(this.channel);
            conversationsMarkRequest.ts(this.ts);
            return conversationsMarkRequest;
        }

        /**
         * Execute mark request
         * @return ConversationsMarkResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsMarkResponse execute() throws ApiException {
            ConversationsMarkRequest conversationsMarkRequest = buildBodyParams();
            ApiResponse<ConversationsMarkResponse> localVarResp = markWithHttpInfo(token, channel, ts, conversationsMarkRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute mark request with HTTP info returned
         * @return ApiResponse&lt;ConversationsMarkResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsMarkResponse> executeWithHttpInfo() throws ApiException {
            ConversationsMarkRequest conversationsMarkRequest = buildBodyParams();
            return markWithHttpInfo(token, channel, ts, conversationsMarkRequest);
        }

        /**
         * Execute mark request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsMarkResponse> _callback) throws ApiException {
            ConversationsMarkRequest conversationsMarkRequest = buildBodyParams();
            return markAsync(token, channel, ts, conversationsMarkRequest, _callback);
        }
    }

    /**
     * 
     * Sets the read cursor in a channel.
     * @return MarkRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.mark"> Documentation</a>
     */
    public MarkRequestBuilder mark() throws IllegalArgumentException {
        return new MarkRequestBuilder();
    }
    private okhttp3.Call membersCall(String token, String channel, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.members";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call membersValidateBeforeCall(String token, String channel, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        return membersCall(token, channel, limit, cursor, _callback);

    }


    private ApiResponse<ConversationsMembersResponse> membersWithHttpInfo(String token, String channel, Integer limit, String cursor) throws ApiException {
        okhttp3.Call localVarCall = membersValidateBeforeCall(token, channel, limit, cursor, null);
        Type localVarReturnType = new TypeToken<ConversationsMembersResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call membersAsync(String token, String channel, Integer limit, String cursor, final ApiCallback<ConversationsMembersResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = membersValidateBeforeCall(token, channel, limit, cursor, _callback);
        Type localVarReturnType = new TypeToken<ConversationsMembersResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class MembersRequestBuilder {
        private String token;
        private String channel;
        private Integer limit;
        private String cursor;

        private MembersRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional)
         * @return MembersRequestBuilder
         */
        public MembersRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel ID of the conversation to retrieve members for (optional)
         * @return MembersRequestBuilder
         */
        public MembersRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set limit
         * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
         * @return MembersRequestBuilder
         */
        public MembersRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set cursor
         * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail. (optional)
         * @return MembersRequestBuilder
         */
        public MembersRequestBuilder cursor(String cursor) {
            this.cursor = cursor;
            return this;
        }
        
        /**
         * Build call for members
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical paginated success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when an invalid cursor is provided </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return membersCall(token, channel, limit, cursor, _callback);
        }


        /**
         * Execute members request
         * @return ConversationsMembersResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical paginated success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when an invalid cursor is provided </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsMembersResponse execute() throws ApiException {
            ApiResponse<ConversationsMembersResponse> localVarResp = membersWithHttpInfo(token, channel, limit, cursor);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute members request with HTTP info returned
         * @return ApiResponse&lt;ConversationsMembersResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical paginated success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when an invalid cursor is provided </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsMembersResponse> executeWithHttpInfo() throws ApiException {
            return membersWithHttpInfo(token, channel, limit, cursor);
        }

        /**
         * Execute members request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical paginated success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when an invalid cursor is provided </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsMembersResponse> _callback) throws ApiException {
            return membersAsync(token, channel, limit, cursor, _callback);
        }
    }

    /**
     * 
     * Retrieve members of a conversation.
     * @return MembersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical paginated success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when an invalid cursor is provided </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.members"> Documentation</a>
     */
    public MembersRequestBuilder members() throws IllegalArgumentException {
        return new MembersRequestBuilder();
    }
    private okhttp3.Call openCall(String token, String channel, Boolean returnIm, String users, ConversationsOpenRequest conversationsOpenRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsOpenRequest;

        // create path and map variables
        String localVarPath = "/conversations.open";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (returnIm != null) {
            localVarFormParams.put("return_im", returnIm);
        }

        if (users != null) {
            localVarFormParams.put("users", users);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call openValidateBeforeCall(String token, String channel, Boolean returnIm, String users, ConversationsOpenRequest conversationsOpenRequest, final ApiCallback _callback) throws ApiException {
        return openCall(token, channel, returnIm, users, conversationsOpenRequest, _callback);

    }


    private ApiResponse<ConversationsOpenResponse> openWithHttpInfo(String token, String channel, Boolean returnIm, String users, ConversationsOpenRequest conversationsOpenRequest) throws ApiException {
        okhttp3.Call localVarCall = openValidateBeforeCall(token, channel, returnIm, users, conversationsOpenRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsOpenResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call openAsync(String token, String channel, Boolean returnIm, String users, ConversationsOpenRequest conversationsOpenRequest, final ApiCallback<ConversationsOpenResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = openValidateBeforeCall(token, channel, returnIm, users, conversationsOpenRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsOpenResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class OpenRequestBuilder {
        private String token;
        private String channel;
        private Boolean returnIm;
        private String users;

        private OpenRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return OpenRequestBuilder
         */
        public OpenRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead. (optional)
         * @return OpenRequestBuilder
         */
        public OpenRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set returnIm
         * @param returnIm Boolean, indicates you want the full IM channel definition in the response. (optional)
         * @return OpenRequestBuilder
         */
        public OpenRequestBuilder returnIm(Boolean returnIm) {
            this.returnIm = returnIm;
            return this;
        }
        
        /**
         * Set users
         * @param users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;. (optional)
         * @return OpenRequestBuilder
         */
        public OpenRequestBuilder users(String users) {
            this.users = users;
            return this;
        }
        
        /**
         * Build call for open
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsOpenRequest conversationsOpenRequest = buildBodyParams();
            return openCall(token, channel, returnIm, users, conversationsOpenRequest, _callback);
        }

        private ConversationsOpenRequest buildBodyParams() {
            ConversationsOpenRequest conversationsOpenRequest = new ConversationsOpenRequest();
            conversationsOpenRequest.channel(this.channel);
            conversationsOpenRequest.returnIm(this.returnIm);
            conversationsOpenRequest.users(this.users);
            return conversationsOpenRequest;
        }

        /**
         * Execute open request
         * @return ConversationsOpenResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsOpenResponse execute() throws ApiException {
            ConversationsOpenRequest conversationsOpenRequest = buildBodyParams();
            ApiResponse<ConversationsOpenResponse> localVarResp = openWithHttpInfo(token, channel, returnIm, users, conversationsOpenRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute open request with HTTP info returned
         * @return ApiResponse&lt;ConversationsOpenResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsOpenResponse> executeWithHttpInfo() throws ApiException {
            ConversationsOpenRequest conversationsOpenRequest = buildBodyParams();
            return openWithHttpInfo(token, channel, returnIm, users, conversationsOpenRequest);
        }

        /**
         * Execute open request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsOpenResponse> _callback) throws ApiException {
            ConversationsOpenRequest conversationsOpenRequest = buildBodyParams();
            return openAsync(token, channel, returnIm, users, conversationsOpenRequest, _callback);
        }
    }

    /**
     * 
     * Opens or resumes a direct message or multi-person direct message.
     * @return OpenRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.open"> Documentation</a>
     */
    public OpenRequestBuilder open() throws IllegalArgumentException {
        return new OpenRequestBuilder();
    }
    private okhttp3.Call renameCall(String token, String channel, String name, ConversationsRenameRequest conversationsRenameRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsRenameRequest;

        // create path and map variables
        String localVarPath = "/conversations.rename";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (name != null) {
            localVarFormParams.put("name", name);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call renameValidateBeforeCall(String token, String channel, String name, ConversationsRenameRequest conversationsRenameRequest, final ApiCallback _callback) throws ApiException {
        return renameCall(token, channel, name, conversationsRenameRequest, _callback);

    }


    private ApiResponse<ConversationsRenameResponse> renameWithHttpInfo(String token, String channel, String name, ConversationsRenameRequest conversationsRenameRequest) throws ApiException {
        okhttp3.Call localVarCall = renameValidateBeforeCall(token, channel, name, conversationsRenameRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsRenameResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call renameAsync(String token, String channel, String name, ConversationsRenameRequest conversationsRenameRequest, final ApiCallback<ConversationsRenameResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = renameValidateBeforeCall(token, channel, name, conversationsRenameRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsRenameResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class RenameRequestBuilder {
        private String token;
        private String channel;
        private String name;

        private RenameRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return RenameRequestBuilder
         */
        public RenameRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel ID of conversation to rename (optional)
         * @return RenameRequestBuilder
         */
        public RenameRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set name
         * @param name New name for conversation. (optional)
         * @return RenameRequestBuilder
         */
        public RenameRequestBuilder name(String name) {
            this.name = name;
            return this;
        }
        
        /**
         * Build call for rename
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when the calling user is not a member of the conversation </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsRenameRequest conversationsRenameRequest = buildBodyParams();
            return renameCall(token, channel, name, conversationsRenameRequest, _callback);
        }

        private ConversationsRenameRequest buildBodyParams() {
            ConversationsRenameRequest conversationsRenameRequest = new ConversationsRenameRequest();
            conversationsRenameRequest.channel(this.channel);
            conversationsRenameRequest.name(this.name);
            return conversationsRenameRequest;
        }

        /**
         * Execute rename request
         * @return ConversationsRenameResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when the calling user is not a member of the conversation </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsRenameResponse execute() throws ApiException {
            ConversationsRenameRequest conversationsRenameRequest = buildBodyParams();
            ApiResponse<ConversationsRenameResponse> localVarResp = renameWithHttpInfo(token, channel, name, conversationsRenameRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute rename request with HTTP info returned
         * @return ApiResponse&lt;ConversationsRenameResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when the calling user is not a member of the conversation </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsRenameResponse> executeWithHttpInfo() throws ApiException {
            ConversationsRenameRequest conversationsRenameRequest = buildBodyParams();
            return renameWithHttpInfo(token, channel, name, conversationsRenameRequest);
        }

        /**
         * Execute rename request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response when the calling user is not a member of the conversation </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsRenameResponse> _callback) throws ApiException {
            ConversationsRenameRequest conversationsRenameRequest = buildBodyParams();
            return renameAsync(token, channel, name, conversationsRenameRequest, _callback);
        }
    }

    /**
     * 
     * Renames a conversation.
     * @return RenameRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response when the calling user is not a member of the conversation </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.rename"> Documentation</a>
     */
    public RenameRequestBuilder rename() throws IllegalArgumentException {
        return new RenameRequestBuilder();
    }
    private okhttp3.Call repliesCall(String token, String channel, Double ts, Double latest, Double oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/conversations.replies";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (ts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("ts", ts));
        }

        if (latest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latest", latest));
        }

        if (oldest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oldest", oldest));
        }

        if (inclusive != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inclusive", inclusive));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call repliesValidateBeforeCall(String token, String channel, Double ts, Double latest, Double oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        return repliesCall(token, channel, ts, latest, oldest, inclusive, limit, cursor, _callback);

    }


    private ApiResponse<ConversationsRepliesResponse> repliesWithHttpInfo(String token, String channel, Double ts, Double latest, Double oldest, Boolean inclusive, Integer limit, String cursor) throws ApiException {
        okhttp3.Call localVarCall = repliesValidateBeforeCall(token, channel, ts, latest, oldest, inclusive, limit, cursor, null);
        Type localVarReturnType = new TypeToken<ConversationsRepliesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call repliesAsync(String token, String channel, Double ts, Double latest, Double oldest, Boolean inclusive, Integer limit, String cursor, final ApiCallback<ConversationsRepliesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = repliesValidateBeforeCall(token, channel, ts, latest, oldest, inclusive, limit, cursor, _callback);
        Type localVarReturnType = new TypeToken<ConversationsRepliesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class RepliesRequestBuilder {
        private String token;
        private String channel;
        private Double ts;
        private Double latest;
        private Double oldest;
        private Boolean inclusive;
        private Integer limit;
        private String cursor;

        private RepliesRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional)
         * @return RepliesRequestBuilder
         */
        public RepliesRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Conversation ID to fetch thread from. (optional)
         * @return RepliesRequestBuilder
         */
        public RepliesRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set ts
         * @param ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message. (optional)
         * @return RepliesRequestBuilder
         */
        public RepliesRequestBuilder ts(Double ts) {
            this.ts = ts;
            return this;
        }
        
        /**
         * Set latest
         * @param latest End of time range of messages to include in results. (optional)
         * @return RepliesRequestBuilder
         */
        public RepliesRequestBuilder latest(Double latest) {
            this.latest = latest;
            return this;
        }
        
        /**
         * Set oldest
         * @param oldest Start of time range of messages to include in results. (optional)
         * @return RepliesRequestBuilder
         */
        public RepliesRequestBuilder oldest(Double oldest) {
            this.oldest = oldest;
            return this;
        }
        
        /**
         * Set inclusive
         * @param inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional)
         * @return RepliesRequestBuilder
         */
        public RepliesRequestBuilder inclusive(Boolean inclusive) {
            this.inclusive = inclusive;
            return this;
        }
        
        /**
         * Set limit
         * @param limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional)
         * @return RepliesRequestBuilder
         */
        public RepliesRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set cursor
         * @param cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](https://slack.dev) for more detail. (optional)
         * @return RepliesRequestBuilder
         */
        public RepliesRequestBuilder cursor(String cursor) {
            this.cursor = cursor;
            return this;
        }
        
        /**
         * Build call for replies
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return repliesCall(token, channel, ts, latest, oldest, inclusive, limit, cursor, _callback);
        }


        /**
         * Execute replies request
         * @return ConversationsRepliesResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsRepliesResponse execute() throws ApiException {
            ApiResponse<ConversationsRepliesResponse> localVarResp = repliesWithHttpInfo(token, channel, ts, latest, oldest, inclusive, limit, cursor);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute replies request with HTTP info returned
         * @return ApiResponse&lt;ConversationsRepliesResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsRepliesResponse> executeWithHttpInfo() throws ApiException {
            return repliesWithHttpInfo(token, channel, ts, latest, oldest, inclusive, limit, cursor);
        }

        /**
         * Execute replies request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsRepliesResponse> _callback) throws ApiException {
            return repliesAsync(token, channel, ts, latest, oldest, inclusive, limit, cursor, _callback);
        }
    }

    /**
     * 
     * Retrieve a thread of messages posted to a conversation
     * @return RepliesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.replies"> Documentation</a>
     */
    public RepliesRequestBuilder replies() throws IllegalArgumentException {
        return new RepliesRequestBuilder();
    }
    private okhttp3.Call setPurposeCall(String token, String channel, String purpose, ConversationsSetPurposeRequest conversationsSetPurposeRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsSetPurposeRequest;

        // create path and map variables
        String localVarPath = "/conversations.setPurpose";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (purpose != null) {
            localVarFormParams.put("purpose", purpose);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call setPurposeValidateBeforeCall(String token, String channel, String purpose, ConversationsSetPurposeRequest conversationsSetPurposeRequest, final ApiCallback _callback) throws ApiException {
        return setPurposeCall(token, channel, purpose, conversationsSetPurposeRequest, _callback);

    }


    private ApiResponse<ConversationsSetPurposeResponse> setPurposeWithHttpInfo(String token, String channel, String purpose, ConversationsSetPurposeRequest conversationsSetPurposeRequest) throws ApiException {
        okhttp3.Call localVarCall = setPurposeValidateBeforeCall(token, channel, purpose, conversationsSetPurposeRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsSetPurposeResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call setPurposeAsync(String token, String channel, String purpose, ConversationsSetPurposeRequest conversationsSetPurposeRequest, final ApiCallback<ConversationsSetPurposeResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = setPurposeValidateBeforeCall(token, channel, purpose, conversationsSetPurposeRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsSetPurposeResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SetPurposeRequestBuilder {
        private String token;
        private String channel;
        private String purpose;

        private SetPurposeRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return SetPurposeRequestBuilder
         */
        public SetPurposeRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Conversation to set the purpose of (optional)
         * @return SetPurposeRequestBuilder
         */
        public SetPurposeRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set purpose
         * @param purpose A new, specialer purpose (optional)
         * @return SetPurposeRequestBuilder
         */
        public SetPurposeRequestBuilder purpose(String purpose) {
            this.purpose = purpose;
            return this;
        }
        
        /**
         * Build call for setPurpose
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsSetPurposeRequest conversationsSetPurposeRequest = buildBodyParams();
            return setPurposeCall(token, channel, purpose, conversationsSetPurposeRequest, _callback);
        }

        private ConversationsSetPurposeRequest buildBodyParams() {
            ConversationsSetPurposeRequest conversationsSetPurposeRequest = new ConversationsSetPurposeRequest();
            conversationsSetPurposeRequest.channel(this.channel);
            conversationsSetPurposeRequest.purpose(this.purpose);
            return conversationsSetPurposeRequest;
        }

        /**
         * Execute setPurpose request
         * @return ConversationsSetPurposeResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsSetPurposeResponse execute() throws ApiException {
            ConversationsSetPurposeRequest conversationsSetPurposeRequest = buildBodyParams();
            ApiResponse<ConversationsSetPurposeResponse> localVarResp = setPurposeWithHttpInfo(token, channel, purpose, conversationsSetPurposeRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute setPurpose request with HTTP info returned
         * @return ApiResponse&lt;ConversationsSetPurposeResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsSetPurposeResponse> executeWithHttpInfo() throws ApiException {
            ConversationsSetPurposeRequest conversationsSetPurposeRequest = buildBodyParams();
            return setPurposeWithHttpInfo(token, channel, purpose, conversationsSetPurposeRequest);
        }

        /**
         * Execute setPurpose request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsSetPurposeResponse> _callback) throws ApiException {
            ConversationsSetPurposeRequest conversationsSetPurposeRequest = buildBodyParams();
            return setPurposeAsync(token, channel, purpose, conversationsSetPurposeRequest, _callback);
        }
    }

    /**
     * 
     * Sets the purpose for a conversation.
     * @return SetPurposeRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setPurpose"> Documentation</a>
     */
    public SetPurposeRequestBuilder setPurpose() throws IllegalArgumentException {
        return new SetPurposeRequestBuilder();
    }
    private okhttp3.Call setTopicCall(String token, String channel, String topic, ConversationsSetTopicRequest conversationsSetTopicRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsSetTopicRequest;

        // create path and map variables
        String localVarPath = "/conversations.setTopic";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (topic != null) {
            localVarFormParams.put("topic", topic);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call setTopicValidateBeforeCall(String token, String channel, String topic, ConversationsSetTopicRequest conversationsSetTopicRequest, final ApiCallback _callback) throws ApiException {
        return setTopicCall(token, channel, topic, conversationsSetTopicRequest, _callback);

    }


    private ApiResponse<ConversationsSetTopicResponse> setTopicWithHttpInfo(String token, String channel, String topic, ConversationsSetTopicRequest conversationsSetTopicRequest) throws ApiException {
        okhttp3.Call localVarCall = setTopicValidateBeforeCall(token, channel, topic, conversationsSetTopicRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsSetTopicResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call setTopicAsync(String token, String channel, String topic, ConversationsSetTopicRequest conversationsSetTopicRequest, final ApiCallback<ConversationsSetTopicResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = setTopicValidateBeforeCall(token, channel, topic, conversationsSetTopicRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsSetTopicResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SetTopicRequestBuilder {
        private String token;
        private String channel;
        private String topic;

        private SetTopicRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return SetTopicRequestBuilder
         */
        public SetTopicRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Conversation to set the topic of (optional)
         * @return SetTopicRequestBuilder
         */
        public SetTopicRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set topic
         * @param topic The new topic string. Does not support formatting or linkification. (optional)
         * @return SetTopicRequestBuilder
         */
        public SetTopicRequestBuilder topic(String topic) {
            this.topic = topic;
            return this;
        }
        
        /**
         * Build call for setTopic
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsSetTopicRequest conversationsSetTopicRequest = buildBodyParams();
            return setTopicCall(token, channel, topic, conversationsSetTopicRequest, _callback);
        }

        private ConversationsSetTopicRequest buildBodyParams() {
            ConversationsSetTopicRequest conversationsSetTopicRequest = new ConversationsSetTopicRequest();
            conversationsSetTopicRequest.channel(this.channel);
            conversationsSetTopicRequest.topic(this.topic);
            return conversationsSetTopicRequest;
        }

        /**
         * Execute setTopic request
         * @return ConversationsSetTopicResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsSetTopicResponse execute() throws ApiException {
            ConversationsSetTopicRequest conversationsSetTopicRequest = buildBodyParams();
            ApiResponse<ConversationsSetTopicResponse> localVarResp = setTopicWithHttpInfo(token, channel, topic, conversationsSetTopicRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute setTopic request with HTTP info returned
         * @return ApiResponse&lt;ConversationsSetTopicResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsSetTopicResponse> executeWithHttpInfo() throws ApiException {
            ConversationsSetTopicRequest conversationsSetTopicRequest = buildBodyParams();
            return setTopicWithHttpInfo(token, channel, topic, conversationsSetTopicRequest);
        }

        /**
         * Execute setTopic request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsSetTopicResponse> _callback) throws ApiException {
            ConversationsSetTopicRequest conversationsSetTopicRequest = buildBodyParams();
            return setTopicAsync(token, channel, topic, conversationsSetTopicRequest, _callback);
        }
    }

    /**
     * 
     * Sets the topic for a conversation.
     * @return SetTopicRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.setTopic"> Documentation</a>
     */
    public SetTopicRequestBuilder setTopic() throws IllegalArgumentException {
        return new SetTopicRequestBuilder();
    }
    private okhttp3.Call unarchiveCall(String token, String channel, ConversationsUnarchiveRequest conversationsUnarchiveRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = conversationsUnarchiveRequest;

        // create path and map variables
        String localVarPath = "/conversations.unarchive";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call unarchiveValidateBeforeCall(String token, String channel, ConversationsUnarchiveRequest conversationsUnarchiveRequest, final ApiCallback _callback) throws ApiException {
        return unarchiveCall(token, channel, conversationsUnarchiveRequest, _callback);

    }


    private ApiResponse<ConversationsUnarchiveResponse> unarchiveWithHttpInfo(String token, String channel, ConversationsUnarchiveRequest conversationsUnarchiveRequest) throws ApiException {
        okhttp3.Call localVarCall = unarchiveValidateBeforeCall(token, channel, conversationsUnarchiveRequest, null);
        Type localVarReturnType = new TypeToken<ConversationsUnarchiveResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call unarchiveAsync(String token, String channel, ConversationsUnarchiveRequest conversationsUnarchiveRequest, final ApiCallback<ConversationsUnarchiveResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = unarchiveValidateBeforeCall(token, channel, conversationsUnarchiveRequest, _callback);
        Type localVarReturnType = new TypeToken<ConversationsUnarchiveResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UnarchiveRequestBuilder {
        private String token;
        private String channel;

        private UnarchiveRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional)
         * @return UnarchiveRequestBuilder
         */
        public UnarchiveRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel ID of conversation to unarchive (optional)
         * @return UnarchiveRequestBuilder
         */
        public UnarchiveRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Build call for unarchive
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ConversationsUnarchiveRequest conversationsUnarchiveRequest = buildBodyParams();
            return unarchiveCall(token, channel, conversationsUnarchiveRequest, _callback);
        }

        private ConversationsUnarchiveRequest buildBodyParams() {
            ConversationsUnarchiveRequest conversationsUnarchiveRequest = new ConversationsUnarchiveRequest();
            conversationsUnarchiveRequest.channel(this.channel);
            return conversationsUnarchiveRequest;
        }

        /**
         * Execute unarchive request
         * @return ConversationsUnarchiveResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ConversationsUnarchiveResponse execute() throws ApiException {
            ConversationsUnarchiveRequest conversationsUnarchiveRequest = buildBodyParams();
            ApiResponse<ConversationsUnarchiveResponse> localVarResp = unarchiveWithHttpInfo(token, channel, conversationsUnarchiveRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute unarchive request with HTTP info returned
         * @return ApiResponse&lt;ConversationsUnarchiveResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ConversationsUnarchiveResponse> executeWithHttpInfo() throws ApiException {
            ConversationsUnarchiveRequest conversationsUnarchiveRequest = buildBodyParams();
            return unarchiveWithHttpInfo(token, channel, conversationsUnarchiveRequest);
        }

        /**
         * Execute unarchive request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ConversationsUnarchiveResponse> _callback) throws ApiException {
            ConversationsUnarchiveRequest conversationsUnarchiveRequest = buildBodyParams();
            return unarchiveAsync(token, channel, conversationsUnarchiveRequest, _callback);
        }
    }

    /**
     * 
     * Reverses conversation archival.
     * @return UnarchiveRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/conversations.unarchive"> Documentation</a>
     */
    public UnarchiveRequestBuilder unarchive() throws IllegalArgumentException {
        return new UnarchiveRequestBuilder();
    }
}
