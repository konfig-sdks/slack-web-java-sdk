/*
 * Slack Web API
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * The version of the OpenAPI document: 1.7.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ChatDeleteRequest;
import com.konfigthis.client.model.ChatDeleteResponse;
import com.konfigthis.client.model.ChatDeleteScheduledMessageRequest;
import com.konfigthis.client.model.ChatDeleteScheduledMessageResponse;
import com.konfigthis.client.model.ChatDeleteScheduledMessagedefaultResponse;
import com.konfigthis.client.model.ChatDeletedefaultResponse;
import com.konfigthis.client.model.ChatGetPermalinkResponse;
import com.konfigthis.client.model.ChatGetPermalinkdefaultResponse;
import com.konfigthis.client.model.ChatMeMessageRequest;
import com.konfigthis.client.model.ChatMeMessageResponse;
import com.konfigthis.client.model.ChatMeMessagedefaultResponse;
import com.konfigthis.client.model.ChatPostEphemeralRequest;
import com.konfigthis.client.model.ChatPostEphemeralResponse;
import com.konfigthis.client.model.ChatPostEphemeraldefaultResponse;
import com.konfigthis.client.model.ChatPostMessageRequest;
import com.konfigthis.client.model.ChatPostMessageResponse;
import com.konfigthis.client.model.ChatPostMessagedefaultResponse;
import com.konfigthis.client.model.ChatScheduleMessageRequest;
import com.konfigthis.client.model.ChatScheduleMessageResponse;
import com.konfigthis.client.model.ChatScheduleMessagedefaultResponse;
import com.konfigthis.client.model.ChatUnfurlRequest;
import com.konfigthis.client.model.ChatUnfurlResponse;
import com.konfigthis.client.model.ChatUnfurldefaultResponse;
import com.konfigthis.client.model.ChatUpdateRequest;
import com.konfigthis.client.model.ChatUpdateResponse;
import com.konfigthis.client.model.ChatUpdatedefaultResponse;
import com.konfigthis.client.model.ChatscheduledMessagesListResponse;
import com.konfigthis.client.model.ChatscheduledMessagesListdefaultResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class ChatApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ChatApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public ChatApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call deleteCall(String token, Boolean asUser, String channel, Double ts, ChatDeleteRequest chatDeleteRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chatDeleteRequest;

        // create path and map variables
        String localVarPath = "/chat.delete";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asUser != null) {
            localVarFormParams.put("as_user", asUser);
        }

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (ts != null) {
            localVarFormParams.put("ts", ts);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteValidateBeforeCall(String token, Boolean asUser, String channel, Double ts, ChatDeleteRequest chatDeleteRequest, final ApiCallback _callback) throws ApiException {
        return deleteCall(token, asUser, channel, ts, chatDeleteRequest, _callback);

    }


    private ApiResponse<ChatDeleteResponse> deleteWithHttpInfo(String token, Boolean asUser, String channel, Double ts, ChatDeleteRequest chatDeleteRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteValidateBeforeCall(token, asUser, channel, ts, chatDeleteRequest, null);
        Type localVarReturnType = new TypeToken<ChatDeleteResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteAsync(String token, Boolean asUser, String channel, Double ts, ChatDeleteRequest chatDeleteRequest, final ApiCallback<ChatDeleteResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteValidateBeforeCall(token, asUser, channel, ts, chatDeleteRequest, _callback);
        Type localVarReturnType = new TypeToken<ChatDeleteResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class DeleteRequestBuilder {
        private String token;
        private Boolean asUser;
        private String channel;
        private Double ts;

        private DeleteRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;chat:write&#x60; (optional)
         * @return DeleteRequestBuilder
         */
        public DeleteRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set asUser
         * @param asUser Pass true to delete the message as the authed user with &#x60;chat:write:user&#x60; scope. [Bot users](https://slack.dev) in this context are considered authed users. If unused or false, the message will be deleted with &#x60;chat:write:bot&#x60; scope. (optional)
         * @return DeleteRequestBuilder
         */
        public DeleteRequestBuilder asUser(Boolean asUser) {
            this.asUser = asUser;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Channel containing the message to be deleted. (optional)
         * @return DeleteRequestBuilder
         */
        public DeleteRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set ts
         * @param ts Timestamp of the message to be deleted. (optional)
         * @return DeleteRequestBuilder
         */
        public DeleteRequestBuilder ts(Double ts) {
            this.ts = ts;
            return this;
        }
        
        /**
         * Build call for delete
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ChatDeleteRequest chatDeleteRequest = buildBodyParams();
            return deleteCall(token, asUser, channel, ts, chatDeleteRequest, _callback);
        }

        private ChatDeleteRequest buildBodyParams() {
            ChatDeleteRequest chatDeleteRequest = new ChatDeleteRequest();
            chatDeleteRequest.asUser(this.asUser);
            chatDeleteRequest.channel(this.channel);
            chatDeleteRequest.ts(this.ts);
            return chatDeleteRequest;
        }

        /**
         * Execute delete request
         * @return ChatDeleteResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ChatDeleteResponse execute() throws ApiException {
            ChatDeleteRequest chatDeleteRequest = buildBodyParams();
            ApiResponse<ChatDeleteResponse> localVarResp = deleteWithHttpInfo(token, asUser, channel, ts, chatDeleteRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute delete request with HTTP info returned
         * @return ApiResponse&lt;ChatDeleteResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatDeleteResponse> executeWithHttpInfo() throws ApiException {
            ChatDeleteRequest chatDeleteRequest = buildBodyParams();
            return deleteWithHttpInfo(token, asUser, channel, ts, chatDeleteRequest);
        }

        /**
         * Execute delete request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatDeleteResponse> _callback) throws ApiException {
            ChatDeleteRequest chatDeleteRequest = buildBodyParams();
            return deleteAsync(token, asUser, channel, ts, chatDeleteRequest, _callback);
        }
    }

    /**
     * 
     * Deletes a message.
     * @return DeleteRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.delete"> Documentation</a>
     */
    public DeleteRequestBuilder delete() throws IllegalArgumentException {
        return new DeleteRequestBuilder();
    }
    private okhttp3.Call deleteScheduledMessageCall(String token, String channel, String scheduledMessageId, Boolean asUser, ChatDeleteScheduledMessageRequest chatDeleteScheduledMessageRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chatDeleteScheduledMessageRequest;

        // create path and map variables
        String localVarPath = "/chat.deleteScheduledMessage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asUser != null) {
            localVarFormParams.put("as_user", asUser);
        }

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (scheduledMessageId != null) {
            localVarFormParams.put("scheduled_message_id", scheduledMessageId);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteScheduledMessageValidateBeforeCall(String token, String channel, String scheduledMessageId, Boolean asUser, ChatDeleteScheduledMessageRequest chatDeleteScheduledMessageRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'token' is set
        if (token == null) {
            throw new ApiException("Missing the required parameter 'token' when calling deleteScheduledMessage(Async)");
        }

        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling deleteScheduledMessage(Async)");
        }

        // verify the required parameter 'scheduledMessageId' is set
        if (scheduledMessageId == null) {
            throw new ApiException("Missing the required parameter 'scheduledMessageId' when calling deleteScheduledMessage(Async)");
        }

        return deleteScheduledMessageCall(token, channel, scheduledMessageId, asUser, chatDeleteScheduledMessageRequest, _callback);

    }


    private ApiResponse<ChatDeleteScheduledMessageResponse> deleteScheduledMessageWithHttpInfo(String token, String channel, String scheduledMessageId, Boolean asUser, ChatDeleteScheduledMessageRequest chatDeleteScheduledMessageRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteScheduledMessageValidateBeforeCall(token, channel, scheduledMessageId, asUser, chatDeleteScheduledMessageRequest, null);
        Type localVarReturnType = new TypeToken<ChatDeleteScheduledMessageResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call deleteScheduledMessageAsync(String token, String channel, String scheduledMessageId, Boolean asUser, ChatDeleteScheduledMessageRequest chatDeleteScheduledMessageRequest, final ApiCallback<ChatDeleteScheduledMessageResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteScheduledMessageValidateBeforeCall(token, channel, scheduledMessageId, asUser, chatDeleteScheduledMessageRequest, _callback);
        Type localVarReturnType = new TypeToken<ChatDeleteScheduledMessageResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class DeleteScheduledMessageRequestBuilder {
        private final String token;
        private final String channel;
        private final String scheduledMessageId;
        private Boolean asUser;

        private DeleteScheduledMessageRequestBuilder(String token, String channel, String scheduledMessageId) {
            this.token = token;
            this.channel = channel;
            this.scheduledMessageId = scheduledMessageId;
        }

        /**
         * Set asUser
         * @param asUser Pass true to delete the message as the authed user with &#x60;chat:write:user&#x60; scope. [Bot users](https://slack.dev) in this context are considered authed users. If unused or false, the message will be deleted with &#x60;chat:write:bot&#x60; scope. (optional)
         * @return DeleteScheduledMessageRequestBuilder
         */
        public DeleteScheduledMessageRequestBuilder asUser(Boolean asUser) {
            this.asUser = asUser;
            return this;
        }
        
        /**
         * Build call for deleteScheduledMessage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if no message is found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ChatDeleteScheduledMessageRequest chatDeleteScheduledMessageRequest = buildBodyParams();
            return deleteScheduledMessageCall(token, channel, scheduledMessageId, asUser, chatDeleteScheduledMessageRequest, _callback);
        }

        private ChatDeleteScheduledMessageRequest buildBodyParams() {
            ChatDeleteScheduledMessageRequest chatDeleteScheduledMessageRequest = new ChatDeleteScheduledMessageRequest();
            chatDeleteScheduledMessageRequest.asUser(this.asUser);
            chatDeleteScheduledMessageRequest.channel(this.channel);
            chatDeleteScheduledMessageRequest.scheduledMessageId(this.scheduledMessageId);
            return chatDeleteScheduledMessageRequest;
        }

        /**
         * Execute deleteScheduledMessage request
         * @return ChatDeleteScheduledMessageResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if no message is found </td><td>  -  </td></tr>
         </table>
         */
        public ChatDeleteScheduledMessageResponse execute() throws ApiException {
            ChatDeleteScheduledMessageRequest chatDeleteScheduledMessageRequest = buildBodyParams();
            ApiResponse<ChatDeleteScheduledMessageResponse> localVarResp = deleteScheduledMessageWithHttpInfo(token, channel, scheduledMessageId, asUser, chatDeleteScheduledMessageRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute deleteScheduledMessage request with HTTP info returned
         * @return ApiResponse&lt;ChatDeleteScheduledMessageResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if no message is found </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatDeleteScheduledMessageResponse> executeWithHttpInfo() throws ApiException {
            ChatDeleteScheduledMessageRequest chatDeleteScheduledMessageRequest = buildBodyParams();
            return deleteScheduledMessageWithHttpInfo(token, channel, scheduledMessageId, asUser, chatDeleteScheduledMessageRequest);
        }

        /**
         * Execute deleteScheduledMessage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if no message is found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatDeleteScheduledMessageResponse> _callback) throws ApiException {
            ChatDeleteScheduledMessageRequest chatDeleteScheduledMessageRequest = buildBodyParams();
            return deleteScheduledMessageAsync(token, channel, scheduledMessageId, asUser, chatDeleteScheduledMessageRequest, _callback);
        }
    }

    /**
     * 
     * Deletes a pending scheduled message from the queue.
     * @param token Authentication token. Requires scope: &#x60;chat:write&#x60; (required)
     * @param channel The channel the scheduled_message is posting to (required)
     * @param scheduledMessageId &#x60;scheduled_message_id&#x60; returned from call to chat.scheduleMessage (required)
     * @return DeleteScheduledMessageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response if no message is found </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.deleteScheduledMessage"> Documentation</a>
     */
    public DeleteScheduledMessageRequestBuilder deleteScheduledMessage(String token, String channel, String scheduledMessageId) throws IllegalArgumentException {
        if (token == null) throw new IllegalArgumentException("\"token\" is required but got null");
            

        if (channel == null) throw new IllegalArgumentException("\"channel\" is required but got null");
            

        if (scheduledMessageId == null) throw new IllegalArgumentException("\"scheduledMessageId\" is required but got null");
            

        return new DeleteScheduledMessageRequestBuilder(token, channel, scheduledMessageId);
    }
    private okhttp3.Call getPermalinkCall(String token, String channel, String messageTs, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chat.getPermalink";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (token != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("token", token));
        }

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (messageTs != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("message_ts", messageTs));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPermalinkValidateBeforeCall(String token, String channel, String messageTs, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'token' is set
        if (token == null) {
            throw new ApiException("Missing the required parameter 'token' when calling getPermalink(Async)");
        }

        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getPermalink(Async)");
        }

        // verify the required parameter 'messageTs' is set
        if (messageTs == null) {
            throw new ApiException("Missing the required parameter 'messageTs' when calling getPermalink(Async)");
        }

        return getPermalinkCall(token, channel, messageTs, _callback);

    }


    private ApiResponse<ChatGetPermalinkResponse> getPermalinkWithHttpInfo(String token, String channel, String messageTs) throws ApiException {
        okhttp3.Call localVarCall = getPermalinkValidateBeforeCall(token, channel, messageTs, null);
        Type localVarReturnType = new TypeToken<ChatGetPermalinkResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getPermalinkAsync(String token, String channel, String messageTs, final ApiCallback<ChatGetPermalinkResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPermalinkValidateBeforeCall(token, channel, messageTs, _callback);
        Type localVarReturnType = new TypeToken<ChatGetPermalinkResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetPermalinkRequestBuilder {
        private final String token;
        private final String channel;
        private final String messageTs;

        private GetPermalinkRequestBuilder(String token, String channel, String messageTs) {
            this.token = token;
            this.channel = channel;
            this.messageTs = messageTs;
        }

        /**
         * Build call for getPermalink
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Standard success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error response when channel cannot be found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getPermalinkCall(token, channel, messageTs, _callback);
        }


        /**
         * Execute getPermalink request
         * @return ChatGetPermalinkResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Standard success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error response when channel cannot be found </td><td>  -  </td></tr>
         </table>
         */
        public ChatGetPermalinkResponse execute() throws ApiException {
            ApiResponse<ChatGetPermalinkResponse> localVarResp = getPermalinkWithHttpInfo(token, channel, messageTs);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getPermalink request with HTTP info returned
         * @return ApiResponse&lt;ChatGetPermalinkResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Standard success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error response when channel cannot be found </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatGetPermalinkResponse> executeWithHttpInfo() throws ApiException {
            return getPermalinkWithHttpInfo(token, channel, messageTs);
        }

        /**
         * Execute getPermalink request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Standard success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Error response when channel cannot be found </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatGetPermalinkResponse> _callback) throws ApiException {
            return getPermalinkAsync(token, channel, messageTs, _callback);
        }
    }

    /**
     * 
     * Retrieve a permalink URL for a specific extant message
     * @param token Authentication token. Requires scope: &#x60;none&#x60; (required)
     * @param channel The ID of the conversation or channel containing the message (required)
     * @param messageTs A message&#39;s &#x60;ts&#x60; value, uniquely identifying it within a channel (required)
     * @return GetPermalinkRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Standard success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Error response when channel cannot be found </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.getPermalink"> Documentation</a>
     */
    public GetPermalinkRequestBuilder getPermalink(String token, String channel, String messageTs) throws IllegalArgumentException {
        if (token == null) throw new IllegalArgumentException("\"token\" is required but got null");
            

        if (channel == null) throw new IllegalArgumentException("\"channel\" is required but got null");
            

        if (messageTs == null) throw new IllegalArgumentException("\"messageTs\" is required but got null");
            

        return new GetPermalinkRequestBuilder(token, channel, messageTs);
    }
    private okhttp3.Call listCall(String token, String channel, Double latest, Double oldest, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/chat.scheduledMessages.list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("channel", channel));
        }

        if (latest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latest", latest));
        }

        if (oldest != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("oldest", oldest));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listValidateBeforeCall(String token, String channel, Double latest, Double oldest, Integer limit, String cursor, final ApiCallback _callback) throws ApiException {
        return listCall(token, channel, latest, oldest, limit, cursor, _callback);

    }


    private ApiResponse<ChatscheduledMessagesListResponse> listWithHttpInfo(String token, String channel, Double latest, Double oldest, Integer limit, String cursor) throws ApiException {
        okhttp3.Call localVarCall = listValidateBeforeCall(token, channel, latest, oldest, limit, cursor, null);
        Type localVarReturnType = new TypeToken<ChatscheduledMessagesListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAsync(String token, String channel, Double latest, Double oldest, Integer limit, String cursor, final ApiCallback<ChatscheduledMessagesListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listValidateBeforeCall(token, channel, latest, oldest, limit, cursor, _callback);
        Type localVarReturnType = new TypeToken<ChatscheduledMessagesListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListRequestBuilder {
        private String token;
        private String channel;
        private Double latest;
        private Double oldest;
        private Integer limit;
        private String cursor;

        private ListRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;none&#x60; (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel The channel of the scheduled messages (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set latest
         * @param latest A UNIX timestamp of the latest value in the time range (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder latest(Double latest) {
            this.latest = latest;
            return this;
        }
        
        /**
         * Set oldest
         * @param oldest A UNIX timestamp of the oldest value in the time range (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder oldest(Double oldest) {
            this.oldest = oldest;
            return this;
        }
        
        /**
         * Set limit
         * @param limit Maximum number of original entries to return. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set cursor
         * @param cursor For pagination purposes, this is the &#x60;cursor&#x60; value returned from a previous call to &#x60;chat.scheduledmessages.list&#x60; indicating where you want to start this call from. (optional)
         * @return ListRequestBuilder
         */
        public ListRequestBuilder cursor(String cursor) {
            this.cursor = cursor;
            return this;
        }
        
        /**
         * Build call for list
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the channel passed is invalid </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listCall(token, channel, latest, oldest, limit, cursor, _callback);
        }


        /**
         * Execute list request
         * @return ChatscheduledMessagesListResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the channel passed is invalid </td><td>  -  </td></tr>
         </table>
         */
        public ChatscheduledMessagesListResponse execute() throws ApiException {
            ApiResponse<ChatscheduledMessagesListResponse> localVarResp = listWithHttpInfo(token, channel, latest, oldest, limit, cursor);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute list request with HTTP info returned
         * @return ApiResponse&lt;ChatscheduledMessagesListResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the channel passed is invalid </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatscheduledMessagesListResponse> executeWithHttpInfo() throws ApiException {
            return listWithHttpInfo(token, channel, latest, oldest, limit, cursor);
        }

        /**
         * Execute list request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the channel passed is invalid </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatscheduledMessagesListResponse> _callback) throws ApiException {
            return listAsync(token, channel, latest, oldest, limit, cursor, _callback);
        }
    }

    /**
     * 
     * Returns a list of scheduled messages.
     * @return ListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response if the channel passed is invalid </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.scheduledMessages.list"> Documentation</a>
     */
    public ListRequestBuilder list() throws IllegalArgumentException {
        return new ListRequestBuilder();
    }
    private okhttp3.Call meMessageCall(String token, String channel, String text, ChatMeMessageRequest chatMeMessageRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chatMeMessageRequest;

        // create path and map variables
        String localVarPath = "/chat.meMessage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (text != null) {
            localVarFormParams.put("text", text);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call meMessageValidateBeforeCall(String token, String channel, String text, ChatMeMessageRequest chatMeMessageRequest, final ApiCallback _callback) throws ApiException {
        return meMessageCall(token, channel, text, chatMeMessageRequest, _callback);

    }


    private ApiResponse<ChatMeMessageResponse> meMessageWithHttpInfo(String token, String channel, String text, ChatMeMessageRequest chatMeMessageRequest) throws ApiException {
        okhttp3.Call localVarCall = meMessageValidateBeforeCall(token, channel, text, chatMeMessageRequest, null);
        Type localVarReturnType = new TypeToken<ChatMeMessageResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call meMessageAsync(String token, String channel, String text, ChatMeMessageRequest chatMeMessageRequest, final ApiCallback<ChatMeMessageResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = meMessageValidateBeforeCall(token, channel, text, chatMeMessageRequest, _callback);
        Type localVarReturnType = new TypeToken<ChatMeMessageResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class MeMessageRequestBuilder {
        private String token;
        private String channel;
        private String text;

        private MeMessageRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;chat:write&#x60; (optional)
         * @return MeMessageRequestBuilder
         */
        public MeMessageRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name. (optional)
         * @return MeMessageRequestBuilder
         */
        public MeMessageRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set text
         * @param text Text of the message to send. (optional)
         * @return MeMessageRequestBuilder
         */
        public MeMessageRequestBuilder text(String text) {
            this.text = text;
            return this;
        }
        
        /**
         * Build call for meMessage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ChatMeMessageRequest chatMeMessageRequest = buildBodyParams();
            return meMessageCall(token, channel, text, chatMeMessageRequest, _callback);
        }

        private ChatMeMessageRequest buildBodyParams() {
            ChatMeMessageRequest chatMeMessageRequest = new ChatMeMessageRequest();
            chatMeMessageRequest.channel(this.channel);
            chatMeMessageRequest.text(this.text);
            return chatMeMessageRequest;
        }

        /**
         * Execute meMessage request
         * @return ChatMeMessageResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ChatMeMessageResponse execute() throws ApiException {
            ChatMeMessageRequest chatMeMessageRequest = buildBodyParams();
            ApiResponse<ChatMeMessageResponse> localVarResp = meMessageWithHttpInfo(token, channel, text, chatMeMessageRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute meMessage request with HTTP info returned
         * @return ApiResponse&lt;ChatMeMessageResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatMeMessageResponse> executeWithHttpInfo() throws ApiException {
            ChatMeMessageRequest chatMeMessageRequest = buildBodyParams();
            return meMessageWithHttpInfo(token, channel, text, chatMeMessageRequest);
        }

        /**
         * Execute meMessage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatMeMessageResponse> _callback) throws ApiException {
            ChatMeMessageRequest chatMeMessageRequest = buildBodyParams();
            return meMessageAsync(token, channel, text, chatMeMessageRequest, _callback);
        }
    }

    /**
     * 
     * Share a me message into a channel.
     * @return MeMessageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.meMessage"> Documentation</a>
     */
    public MeMessageRequestBuilder meMessage() throws IllegalArgumentException {
        return new MeMessageRequestBuilder();
    }
    private okhttp3.Call postEphemeralCall(String token, String channel, String user, Boolean asUser, String attachments, String blocks, String iconEmoji, String iconUrl, Boolean linkNames, String parse, String text, String threadTs, String username, ChatPostEphemeralRequest chatPostEphemeralRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chatPostEphemeralRequest;

        // create path and map variables
        String localVarPath = "/chat.postEphemeral";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asUser != null) {
            localVarFormParams.put("as_user", asUser);
        }

        if (attachments != null) {
            localVarFormParams.put("attachments", attachments);
        }

        if (blocks != null) {
            localVarFormParams.put("blocks", blocks);
        }

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (iconEmoji != null) {
            localVarFormParams.put("icon_emoji", iconEmoji);
        }

        if (iconUrl != null) {
            localVarFormParams.put("icon_url", iconUrl);
        }

        if (linkNames != null) {
            localVarFormParams.put("link_names", linkNames);
        }

        if (parse != null) {
            localVarFormParams.put("parse", parse);
        }

        if (text != null) {
            localVarFormParams.put("text", text);
        }

        if (threadTs != null) {
            localVarFormParams.put("thread_ts", threadTs);
        }

        if (user != null) {
            localVarFormParams.put("user", user);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postEphemeralValidateBeforeCall(String token, String channel, String user, Boolean asUser, String attachments, String blocks, String iconEmoji, String iconUrl, Boolean linkNames, String parse, String text, String threadTs, String username, ChatPostEphemeralRequest chatPostEphemeralRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'token' is set
        if (token == null) {
            throw new ApiException("Missing the required parameter 'token' when calling postEphemeral(Async)");
        }

        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling postEphemeral(Async)");
        }

        // verify the required parameter 'user' is set
        if (user == null) {
            throw new ApiException("Missing the required parameter 'user' when calling postEphemeral(Async)");
        }

        return postEphemeralCall(token, channel, user, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, parse, text, threadTs, username, chatPostEphemeralRequest, _callback);

    }


    private ApiResponse<ChatPostEphemeralResponse> postEphemeralWithHttpInfo(String token, String channel, String user, Boolean asUser, String attachments, String blocks, String iconEmoji, String iconUrl, Boolean linkNames, String parse, String text, String threadTs, String username, ChatPostEphemeralRequest chatPostEphemeralRequest) throws ApiException {
        okhttp3.Call localVarCall = postEphemeralValidateBeforeCall(token, channel, user, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, parse, text, threadTs, username, chatPostEphemeralRequest, null);
        Type localVarReturnType = new TypeToken<ChatPostEphemeralResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call postEphemeralAsync(String token, String channel, String user, Boolean asUser, String attachments, String blocks, String iconEmoji, String iconUrl, Boolean linkNames, String parse, String text, String threadTs, String username, ChatPostEphemeralRequest chatPostEphemeralRequest, final ApiCallback<ChatPostEphemeralResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = postEphemeralValidateBeforeCall(token, channel, user, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, parse, text, threadTs, username, chatPostEphemeralRequest, _callback);
        Type localVarReturnType = new TypeToken<ChatPostEphemeralResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class PostEphemeralRequestBuilder {
        private final String token;
        private final String channel;
        private final String user;
        private Boolean asUser;
        private String attachments;
        private String blocks;
        private String iconEmoji;
        private String iconUrl;
        private Boolean linkNames;
        private String parse;
        private String text;
        private String threadTs;
        private String username;

        private PostEphemeralRequestBuilder(String token, String channel, String user) {
            this.token = token;
            this.channel = channel;
            this.user = user;
        }

        /**
         * Set asUser
         * @param asUser Pass true to post the message as the authed user. Defaults to true if the chat:write:bot scope is not included. Otherwise, defaults to false. (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder asUser(Boolean asUser) {
            this.asUser = asUser;
            return this;
        }
        
        /**
         * Set attachments
         * @param attachments A JSON-based array of structured attachments, presented as a URL-encoded string. (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder attachments(String attachments) {
            this.attachments = attachments;
            return this;
        }
        
        /**
         * Set blocks
         * @param blocks A JSON-based array of structured blocks, presented as a URL-encoded string. (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder blocks(String blocks) {
            this.blocks = blocks;
            return this;
        }
        
        /**
         * Set iconEmoji
         * @param iconEmoji Emoji to use as the icon for this message. Overrides &#x60;icon_url&#x60;. Must be used in conjunction with &#x60;as_user&#x60; set to &#x60;false&#x60;, otherwise ignored. See [authorship](https://slack.dev) below. (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder iconEmoji(String iconEmoji) {
            this.iconEmoji = iconEmoji;
            return this;
        }
        
        /**
         * Set iconUrl
         * @param iconUrl URL to an image to use as the icon for this message. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](https://slack.dev) below. (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder iconUrl(String iconUrl) {
            this.iconUrl = iconUrl;
            return this;
        }
        
        /**
         * Set linkNames
         * @param linkNames Find and link channel names and usernames. (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder linkNames(Boolean linkNames) {
            this.linkNames = linkNames;
            return this;
        }
        
        /**
         * Set parse
         * @param parse Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](https://slack.dev). (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder parse(String parse) {
            this.parse = parse;
            return this;
        }
        
        /**
         * Set text
         * @param text How this field works and whether it is required depends on other fields you use in your API call. [See below](https://slack.dev) for more detail. (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder text(String text) {
            this.text = text;
            return this;
        }
        
        /**
         * Set threadTs
         * @param threadTs Provide another message&#39;s &#x60;ts&#x60; value to post this message in a thread. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent&#39;s value instead. Ephemeral messages in threads are only shown if there is already an active thread. (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder threadTs(String threadTs) {
            this.threadTs = threadTs;
            return this;
        }
        
        /**
         * Set username
         * @param username Set your bot&#39;s user name. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](https://slack.dev) below. (optional)
         * @return PostEphemeralRequestBuilder
         */
        public PostEphemeralRequestBuilder username(String username) {
            this.username = username;
            return this;
        }
        
        /**
         * Build call for postEphemeral
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ChatPostEphemeralRequest chatPostEphemeralRequest = buildBodyParams();
            return postEphemeralCall(token, channel, user, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, parse, text, threadTs, username, chatPostEphemeralRequest, _callback);
        }

        private ChatPostEphemeralRequest buildBodyParams() {
            ChatPostEphemeralRequest chatPostEphemeralRequest = new ChatPostEphemeralRequest();
            chatPostEphemeralRequest.asUser(this.asUser);
            chatPostEphemeralRequest.attachments(this.attachments);
            chatPostEphemeralRequest.blocks(this.blocks);
            chatPostEphemeralRequest.channel(this.channel);
            chatPostEphemeralRequest.iconEmoji(this.iconEmoji);
            chatPostEphemeralRequest.iconUrl(this.iconUrl);
            chatPostEphemeralRequest.linkNames(this.linkNames);
            chatPostEphemeralRequest.parse(this.parse);
            chatPostEphemeralRequest.text(this.text);
            chatPostEphemeralRequest.threadTs(this.threadTs);
            chatPostEphemeralRequest.user(this.user);
            chatPostEphemeralRequest.username(this.username);
            return chatPostEphemeralRequest;
        }

        /**
         * Execute postEphemeral request
         * @return ChatPostEphemeralResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ChatPostEphemeralResponse execute() throws ApiException {
            ChatPostEphemeralRequest chatPostEphemeralRequest = buildBodyParams();
            ApiResponse<ChatPostEphemeralResponse> localVarResp = postEphemeralWithHttpInfo(token, channel, user, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, parse, text, threadTs, username, chatPostEphemeralRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute postEphemeral request with HTTP info returned
         * @return ApiResponse&lt;ChatPostEphemeralResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatPostEphemeralResponse> executeWithHttpInfo() throws ApiException {
            ChatPostEphemeralRequest chatPostEphemeralRequest = buildBodyParams();
            return postEphemeralWithHttpInfo(token, channel, user, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, parse, text, threadTs, username, chatPostEphemeralRequest);
        }

        /**
         * Execute postEphemeral request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatPostEphemeralResponse> _callback) throws ApiException {
            ChatPostEphemeralRequest chatPostEphemeralRequest = buildBodyParams();
            return postEphemeralAsync(token, channel, user, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, parse, text, threadTs, username, chatPostEphemeralRequest, _callback);
        }
    }

    /**
     * 
     * Sends an ephemeral message to a user in a channel.
     * @param token Authentication token. Requires scope: &#x60;chat:write&#x60; (required)
     * @param channel Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. (required)
     * @param user &#x60;id&#x60; of the user who will receive the ephemeral message. The user should be in the channel specified by the &#x60;channel&#x60; argument. (required)
     * @return PostEphemeralRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.postEphemeral"> Documentation</a>
     */
    public PostEphemeralRequestBuilder postEphemeral(String token, String channel, String user) throws IllegalArgumentException {
        if (token == null) throw new IllegalArgumentException("\"token\" is required but got null");
            

        if (channel == null) throw new IllegalArgumentException("\"channel\" is required but got null");
            

        if (user == null) throw new IllegalArgumentException("\"user\" is required but got null");
            

        return new PostEphemeralRequestBuilder(token, channel, user);
    }
    private okhttp3.Call postMessageCall(String token, String channel, String asUser, String attachments, String blocks, String iconEmoji, String iconUrl, Boolean linkNames, Boolean mrkdwn, String parse, Boolean replyBroadcast, String text, String threadTs, Boolean unfurlLinks, Boolean unfurlMedia, String username, ChatPostMessageRequest chatPostMessageRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chatPostMessageRequest;

        // create path and map variables
        String localVarPath = "/chat.postMessage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asUser != null) {
            localVarFormParams.put("as_user", asUser);
        }

        if (attachments != null) {
            localVarFormParams.put("attachments", attachments);
        }

        if (blocks != null) {
            localVarFormParams.put("blocks", blocks);
        }

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (iconEmoji != null) {
            localVarFormParams.put("icon_emoji", iconEmoji);
        }

        if (iconUrl != null) {
            localVarFormParams.put("icon_url", iconUrl);
        }

        if (linkNames != null) {
            localVarFormParams.put("link_names", linkNames);
        }

        if (mrkdwn != null) {
            localVarFormParams.put("mrkdwn", mrkdwn);
        }

        if (parse != null) {
            localVarFormParams.put("parse", parse);
        }

        if (replyBroadcast != null) {
            localVarFormParams.put("reply_broadcast", replyBroadcast);
        }

        if (text != null) {
            localVarFormParams.put("text", text);
        }

        if (threadTs != null) {
            localVarFormParams.put("thread_ts", threadTs);
        }

        if (unfurlLinks != null) {
            localVarFormParams.put("unfurl_links", unfurlLinks);
        }

        if (unfurlMedia != null) {
            localVarFormParams.put("unfurl_media", unfurlMedia);
        }

        if (username != null) {
            localVarFormParams.put("username", username);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postMessageValidateBeforeCall(String token, String channel, String asUser, String attachments, String blocks, String iconEmoji, String iconUrl, Boolean linkNames, Boolean mrkdwn, String parse, Boolean replyBroadcast, String text, String threadTs, Boolean unfurlLinks, Boolean unfurlMedia, String username, ChatPostMessageRequest chatPostMessageRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'token' is set
        if (token == null) {
            throw new ApiException("Missing the required parameter 'token' when calling postMessage(Async)");
        }

        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling postMessage(Async)");
        }

        return postMessageCall(token, channel, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, mrkdwn, parse, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, username, chatPostMessageRequest, _callback);

    }


    private ApiResponse<ChatPostMessageResponse> postMessageWithHttpInfo(String token, String channel, String asUser, String attachments, String blocks, String iconEmoji, String iconUrl, Boolean linkNames, Boolean mrkdwn, String parse, Boolean replyBroadcast, String text, String threadTs, Boolean unfurlLinks, Boolean unfurlMedia, String username, ChatPostMessageRequest chatPostMessageRequest) throws ApiException {
        okhttp3.Call localVarCall = postMessageValidateBeforeCall(token, channel, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, mrkdwn, parse, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, username, chatPostMessageRequest, null);
        Type localVarReturnType = new TypeToken<ChatPostMessageResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call postMessageAsync(String token, String channel, String asUser, String attachments, String blocks, String iconEmoji, String iconUrl, Boolean linkNames, Boolean mrkdwn, String parse, Boolean replyBroadcast, String text, String threadTs, Boolean unfurlLinks, Boolean unfurlMedia, String username, ChatPostMessageRequest chatPostMessageRequest, final ApiCallback<ChatPostMessageResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = postMessageValidateBeforeCall(token, channel, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, mrkdwn, parse, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, username, chatPostMessageRequest, _callback);
        Type localVarReturnType = new TypeToken<ChatPostMessageResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class PostMessageRequestBuilder {
        private final String token;
        private final String channel;
        private String asUser;
        private String attachments;
        private String blocks;
        private String iconEmoji;
        private String iconUrl;
        private Boolean linkNames;
        private Boolean mrkdwn;
        private String parse;
        private Boolean replyBroadcast;
        private String text;
        private String threadTs;
        private Boolean unfurlLinks;
        private Boolean unfurlMedia;
        private String username;

        private PostMessageRequestBuilder(String token, String channel) {
            this.token = token;
            this.channel = channel;
        }

        /**
         * Set asUser
         * @param asUser Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](https://slack.dev) below. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder asUser(String asUser) {
            this.asUser = asUser;
            return this;
        }
        
        /**
         * Set attachments
         * @param attachments A JSON-based array of structured attachments, presented as a URL-encoded string. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder attachments(String attachments) {
            this.attachments = attachments;
            return this;
        }
        
        /**
         * Set blocks
         * @param blocks A JSON-based array of structured blocks, presented as a URL-encoded string. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder blocks(String blocks) {
            this.blocks = blocks;
            return this;
        }
        
        /**
         * Set iconEmoji
         * @param iconEmoji Emoji to use as the icon for this message. Overrides &#x60;icon_url&#x60;. Must be used in conjunction with &#x60;as_user&#x60; set to &#x60;false&#x60;, otherwise ignored. See [authorship](https://slack.dev) below. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder iconEmoji(String iconEmoji) {
            this.iconEmoji = iconEmoji;
            return this;
        }
        
        /**
         * Set iconUrl
         * @param iconUrl URL to an image to use as the icon for this message. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](https://slack.dev) below. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder iconUrl(String iconUrl) {
            this.iconUrl = iconUrl;
            return this;
        }
        
        /**
         * Set linkNames
         * @param linkNames Find and link channel names and usernames. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder linkNames(Boolean linkNames) {
            this.linkNames = linkNames;
            return this;
        }
        
        /**
         * Set mrkdwn
         * @param mrkdwn Disable Slack markup parsing by setting to &#x60;false&#x60;. Enabled by default. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder mrkdwn(Boolean mrkdwn) {
            this.mrkdwn = mrkdwn;
            return this;
        }
        
        /**
         * Set parse
         * @param parse Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](https://slack.dev). (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder parse(String parse) {
            this.parse = parse;
            return this;
        }
        
        /**
         * Set replyBroadcast
         * @param replyBroadcast Used in conjunction with &#x60;thread_ts&#x60; and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to &#x60;false&#x60;. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder replyBroadcast(Boolean replyBroadcast) {
            this.replyBroadcast = replyBroadcast;
            return this;
        }
        
        /**
         * Set text
         * @param text How this field works and whether it is required depends on other fields you use in your API call. [See below](https://slack.dev) for more detail. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder text(String text) {
            this.text = text;
            return this;
        }
        
        /**
         * Set threadTs
         * @param threadTs Provide another message&#39;s &#x60;ts&#x60; value to make this message a reply. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent instead. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder threadTs(String threadTs) {
            this.threadTs = threadTs;
            return this;
        }
        
        /**
         * Set unfurlLinks
         * @param unfurlLinks Pass true to enable unfurling of primarily text-based content. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder unfurlLinks(Boolean unfurlLinks) {
            this.unfurlLinks = unfurlLinks;
            return this;
        }
        
        /**
         * Set unfurlMedia
         * @param unfurlMedia Pass false to disable unfurling of media content. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder unfurlMedia(Boolean unfurlMedia) {
            this.unfurlMedia = unfurlMedia;
            return this;
        }
        
        /**
         * Set username
         * @param username Set your bot&#39;s user name. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](https://slack.dev) below. (optional)
         * @return PostMessageRequestBuilder
         */
        public PostMessageRequestBuilder username(String username) {
            this.username = username;
            return this;
        }
        
        /**
         * Build call for postMessage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if too many attachments are included </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ChatPostMessageRequest chatPostMessageRequest = buildBodyParams();
            return postMessageCall(token, channel, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, mrkdwn, parse, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, username, chatPostMessageRequest, _callback);
        }

        private ChatPostMessageRequest buildBodyParams() {
            ChatPostMessageRequest chatPostMessageRequest = new ChatPostMessageRequest();
            chatPostMessageRequest.asUser(this.asUser);
            chatPostMessageRequest.attachments(this.attachments);
            chatPostMessageRequest.blocks(this.blocks);
            chatPostMessageRequest.channel(this.channel);
            chatPostMessageRequest.iconEmoji(this.iconEmoji);
            chatPostMessageRequest.iconUrl(this.iconUrl);
            chatPostMessageRequest.linkNames(this.linkNames);
            chatPostMessageRequest.mrkdwn(this.mrkdwn);
            chatPostMessageRequest.parse(this.parse);
            chatPostMessageRequest.replyBroadcast(this.replyBroadcast);
            chatPostMessageRequest.text(this.text);
            chatPostMessageRequest.threadTs(this.threadTs);
            chatPostMessageRequest.unfurlLinks(this.unfurlLinks);
            chatPostMessageRequest.unfurlMedia(this.unfurlMedia);
            chatPostMessageRequest.username(this.username);
            return chatPostMessageRequest;
        }

        /**
         * Execute postMessage request
         * @return ChatPostMessageResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if too many attachments are included </td><td>  -  </td></tr>
         </table>
         */
        public ChatPostMessageResponse execute() throws ApiException {
            ChatPostMessageRequest chatPostMessageRequest = buildBodyParams();
            ApiResponse<ChatPostMessageResponse> localVarResp = postMessageWithHttpInfo(token, channel, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, mrkdwn, parse, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, username, chatPostMessageRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute postMessage request with HTTP info returned
         * @return ApiResponse&lt;ChatPostMessageResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if too many attachments are included </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatPostMessageResponse> executeWithHttpInfo() throws ApiException {
            ChatPostMessageRequest chatPostMessageRequest = buildBodyParams();
            return postMessageWithHttpInfo(token, channel, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, mrkdwn, parse, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, username, chatPostMessageRequest);
        }

        /**
         * Execute postMessage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if too many attachments are included </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatPostMessageResponse> _callback) throws ApiException {
            ChatPostMessageRequest chatPostMessageRequest = buildBodyParams();
            return postMessageAsync(token, channel, asUser, attachments, blocks, iconEmoji, iconUrl, linkNames, mrkdwn, parse, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, username, chatPostMessageRequest, _callback);
        }
    }

    /**
     * 
     * Sends a message to a channel.
     * @param token Authentication token. Requires scope: &#x60;chat:write&#x60; (required)
     * @param channel Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](https://slack.dev) for more details. (required)
     * @return PostMessageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response if too many attachments are included </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.postMessage"> Documentation</a>
     */
    public PostMessageRequestBuilder postMessage(String token, String channel) throws IllegalArgumentException {
        if (token == null) throw new IllegalArgumentException("\"token\" is required but got null");
            

        if (channel == null) throw new IllegalArgumentException("\"channel\" is required but got null");
            

        return new PostMessageRequestBuilder(token, channel);
    }
    private okhttp3.Call scheduleMessageCall(String token, Boolean asUser, String attachments, String blocks, String channel, Boolean linkNames, String parse, String postAt, Boolean replyBroadcast, String text, Double threadTs, Boolean unfurlLinks, Boolean unfurlMedia, ChatScheduleMessageRequest chatScheduleMessageRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chatScheduleMessageRequest;

        // create path and map variables
        String localVarPath = "/chat.scheduleMessage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asUser != null) {
            localVarFormParams.put("as_user", asUser);
        }

        if (attachments != null) {
            localVarFormParams.put("attachments", attachments);
        }

        if (blocks != null) {
            localVarFormParams.put("blocks", blocks);
        }

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (linkNames != null) {
            localVarFormParams.put("link_names", linkNames);
        }

        if (parse != null) {
            localVarFormParams.put("parse", parse);
        }

        if (postAt != null) {
            localVarFormParams.put("post_at", postAt);
        }

        if (replyBroadcast != null) {
            localVarFormParams.put("reply_broadcast", replyBroadcast);
        }

        if (text != null) {
            localVarFormParams.put("text", text);
        }

        if (threadTs != null) {
            localVarFormParams.put("thread_ts", threadTs);
        }

        if (unfurlLinks != null) {
            localVarFormParams.put("unfurl_links", unfurlLinks);
        }

        if (unfurlMedia != null) {
            localVarFormParams.put("unfurl_media", unfurlMedia);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call scheduleMessageValidateBeforeCall(String token, Boolean asUser, String attachments, String blocks, String channel, Boolean linkNames, String parse, String postAt, Boolean replyBroadcast, String text, Double threadTs, Boolean unfurlLinks, Boolean unfurlMedia, ChatScheduleMessageRequest chatScheduleMessageRequest, final ApiCallback _callback) throws ApiException {
        return scheduleMessageCall(token, asUser, attachments, blocks, channel, linkNames, parse, postAt, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, chatScheduleMessageRequest, _callback);

    }


    private ApiResponse<ChatScheduleMessageResponse> scheduleMessageWithHttpInfo(String token, Boolean asUser, String attachments, String blocks, String channel, Boolean linkNames, String parse, String postAt, Boolean replyBroadcast, String text, Double threadTs, Boolean unfurlLinks, Boolean unfurlMedia, ChatScheduleMessageRequest chatScheduleMessageRequest) throws ApiException {
        okhttp3.Call localVarCall = scheduleMessageValidateBeforeCall(token, asUser, attachments, blocks, channel, linkNames, parse, postAt, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, chatScheduleMessageRequest, null);
        Type localVarReturnType = new TypeToken<ChatScheduleMessageResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call scheduleMessageAsync(String token, Boolean asUser, String attachments, String blocks, String channel, Boolean linkNames, String parse, String postAt, Boolean replyBroadcast, String text, Double threadTs, Boolean unfurlLinks, Boolean unfurlMedia, ChatScheduleMessageRequest chatScheduleMessageRequest, final ApiCallback<ChatScheduleMessageResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = scheduleMessageValidateBeforeCall(token, asUser, attachments, blocks, channel, linkNames, parse, postAt, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, chatScheduleMessageRequest, _callback);
        Type localVarReturnType = new TypeToken<ChatScheduleMessageResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ScheduleMessageRequestBuilder {
        private String token;
        private Boolean asUser;
        private String attachments;
        private String blocks;
        private String channel;
        private Boolean linkNames;
        private String parse;
        private String postAt;
        private Boolean replyBroadcast;
        private String text;
        private Double threadTs;
        private Boolean unfurlLinks;
        private Boolean unfurlMedia;

        private ScheduleMessageRequestBuilder() {
        }

        /**
         * Set token
         * @param token Authentication token. Requires scope: &#x60;chat:write&#x60; (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder token(String token) {
            this.token = token;
            return this;
        }
        
        /**
         * Set asUser
         * @param asUser Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [chat.postMessage](chat.postMessage#authorship). (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder asUser(Boolean asUser) {
            this.asUser = asUser;
            return this;
        }
        
        /**
         * Set attachments
         * @param attachments A JSON-based array of structured attachments, presented as a URL-encoded string. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder attachments(String attachments) {
            this.attachments = attachments;
            return this;
        }
        
        /**
         * Set blocks
         * @param blocks A JSON-based array of structured blocks, presented as a URL-encoded string. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder blocks(String blocks) {
            this.blocks = blocks;
            return this;
        }
        
        /**
         * Set channel
         * @param channel Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name. See [below](https://slack.dev) for more details. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder channel(String channel) {
            this.channel = channel;
            return this;
        }
        
        /**
         * Set linkNames
         * @param linkNames Find and link channel names and usernames. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder linkNames(Boolean linkNames) {
            this.linkNames = linkNames;
            return this;
        }
        
        /**
         * Set parse
         * @param parse Change how messages are treated. Defaults to &#x60;none&#x60;. See [chat.postMessage](chat.postMessage#formatting). (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder parse(String parse) {
            this.parse = parse;
            return this;
        }
        
        /**
         * Set postAt
         * @param postAt Unix EPOCH timestamp of time in future to send the message. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder postAt(String postAt) {
            this.postAt = postAt;
            return this;
        }
        
        /**
         * Set replyBroadcast
         * @param replyBroadcast Used in conjunction with &#x60;thread_ts&#x60; and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to &#x60;false&#x60;. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder replyBroadcast(Boolean replyBroadcast) {
            this.replyBroadcast = replyBroadcast;
            return this;
        }
        
        /**
         * Set text
         * @param text How this field works and whether it is required depends on other fields you use in your API call. [See below](https://slack.dev) for more detail. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder text(String text) {
            this.text = text;
            return this;
        }
        
        /**
         * Set threadTs
         * @param threadTs Provide another message&#39;s &#x60;ts&#x60; value to make this message a reply. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent instead. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder threadTs(Double threadTs) {
            this.threadTs = threadTs;
            return this;
        }
        
        /**
         * Set unfurlLinks
         * @param unfurlLinks Pass true to enable unfurling of primarily text-based content. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder unfurlLinks(Boolean unfurlLinks) {
            this.unfurlLinks = unfurlLinks;
            return this;
        }
        
        /**
         * Set unfurlMedia
         * @param unfurlMedia Pass false to disable unfurling of media content. (optional)
         * @return ScheduleMessageRequestBuilder
         */
        public ScheduleMessageRequestBuilder unfurlMedia(Boolean unfurlMedia) {
            this.unfurlMedia = unfurlMedia;
            return this;
        }
        
        /**
         * Build call for scheduleMessage
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the &#x60;post_at&#x60; is invalid (ex. in the past or too far into the future) </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ChatScheduleMessageRequest chatScheduleMessageRequest = buildBodyParams();
            return scheduleMessageCall(token, asUser, attachments, blocks, channel, linkNames, parse, postAt, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, chatScheduleMessageRequest, _callback);
        }

        private ChatScheduleMessageRequest buildBodyParams() {
            ChatScheduleMessageRequest chatScheduleMessageRequest = new ChatScheduleMessageRequest();
            chatScheduleMessageRequest.asUser(this.asUser);
            chatScheduleMessageRequest.attachments(this.attachments);
            chatScheduleMessageRequest.blocks(this.blocks);
            chatScheduleMessageRequest.channel(this.channel);
            chatScheduleMessageRequest.linkNames(this.linkNames);
            chatScheduleMessageRequest.parse(this.parse);
            chatScheduleMessageRequest.postAt(this.postAt);
            chatScheduleMessageRequest.replyBroadcast(this.replyBroadcast);
            chatScheduleMessageRequest.text(this.text);
            chatScheduleMessageRequest.threadTs(this.threadTs);
            chatScheduleMessageRequest.unfurlLinks(this.unfurlLinks);
            chatScheduleMessageRequest.unfurlMedia(this.unfurlMedia);
            return chatScheduleMessageRequest;
        }

        /**
         * Execute scheduleMessage request
         * @return ChatScheduleMessageResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the &#x60;post_at&#x60; is invalid (ex. in the past or too far into the future) </td><td>  -  </td></tr>
         </table>
         */
        public ChatScheduleMessageResponse execute() throws ApiException {
            ChatScheduleMessageRequest chatScheduleMessageRequest = buildBodyParams();
            ApiResponse<ChatScheduleMessageResponse> localVarResp = scheduleMessageWithHttpInfo(token, asUser, attachments, blocks, channel, linkNames, parse, postAt, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, chatScheduleMessageRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute scheduleMessage request with HTTP info returned
         * @return ApiResponse&lt;ChatScheduleMessageResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the &#x60;post_at&#x60; is invalid (ex. in the past or too far into the future) </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatScheduleMessageResponse> executeWithHttpInfo() throws ApiException {
            ChatScheduleMessageRequest chatScheduleMessageRequest = buildBodyParams();
            return scheduleMessageWithHttpInfo(token, asUser, attachments, blocks, channel, linkNames, parse, postAt, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, chatScheduleMessageRequest);
        }

        /**
         * Execute scheduleMessage request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response if the &#x60;post_at&#x60; is invalid (ex. in the past or too far into the future) </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatScheduleMessageResponse> _callback) throws ApiException {
            ChatScheduleMessageRequest chatScheduleMessageRequest = buildBodyParams();
            return scheduleMessageAsync(token, asUser, attachments, blocks, channel, linkNames, parse, postAt, replyBroadcast, text, threadTs, unfurlLinks, unfurlMedia, chatScheduleMessageRequest, _callback);
        }
    }

    /**
     * 
     * Schedules a message to be sent to a channel.
     * @return ScheduleMessageRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response if the &#x60;post_at&#x60; is invalid (ex. in the past or too far into the future) </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.scheduleMessage"> Documentation</a>
     */
    public ScheduleMessageRequestBuilder scheduleMessage() throws IllegalArgumentException {
        return new ScheduleMessageRequestBuilder();
    }
    private okhttp3.Call unfurlCall(String token, String channel, String ts, ChatUnfurlRequest chatUnfurlRequest, String unfurls, String userAuthMessage, Boolean userAuthRequired, String userAuthUrl, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chatUnfurlRequest;

        // create path and map variables
        String localVarPath = "/chat.unfurl";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (ts != null) {
            localVarFormParams.put("ts", ts);
        }

        if (unfurls != null) {
            localVarFormParams.put("unfurls", unfurls);
        }

        if (userAuthMessage != null) {
            localVarFormParams.put("user_auth_message", userAuthMessage);
        }

        if (userAuthRequired != null) {
            localVarFormParams.put("user_auth_required", userAuthRequired);
        }

        if (userAuthUrl != null) {
            localVarFormParams.put("user_auth_url", userAuthUrl);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call unfurlValidateBeforeCall(String token, String channel, String ts, ChatUnfurlRequest chatUnfurlRequest, String unfurls, String userAuthMessage, Boolean userAuthRequired, String userAuthUrl, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'token' is set
        if (token == null) {
            throw new ApiException("Missing the required parameter 'token' when calling unfurl(Async)");
        }

        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling unfurl(Async)");
        }

        // verify the required parameter 'ts' is set
        if (ts == null) {
            throw new ApiException("Missing the required parameter 'ts' when calling unfurl(Async)");
        }

        // verify the required parameter 'chatUnfurlRequest' is set
        if (chatUnfurlRequest == null) {
            throw new ApiException("Missing the required parameter 'chatUnfurlRequest' when calling unfurl(Async)");
        }

        return unfurlCall(token, channel, ts, chatUnfurlRequest, unfurls, userAuthMessage, userAuthRequired, userAuthUrl, _callback);

    }


    private ApiResponse<ChatUnfurlResponse> unfurlWithHttpInfo(String token, String channel, String ts, ChatUnfurlRequest chatUnfurlRequest, String unfurls, String userAuthMessage, Boolean userAuthRequired, String userAuthUrl) throws ApiException {
        okhttp3.Call localVarCall = unfurlValidateBeforeCall(token, channel, ts, chatUnfurlRequest, unfurls, userAuthMessage, userAuthRequired, userAuthUrl, null);
        Type localVarReturnType = new TypeToken<ChatUnfurlResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call unfurlAsync(String token, String channel, String ts, ChatUnfurlRequest chatUnfurlRequest, String unfurls, String userAuthMessage, Boolean userAuthRequired, String userAuthUrl, final ApiCallback<ChatUnfurlResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = unfurlValidateBeforeCall(token, channel, ts, chatUnfurlRequest, unfurls, userAuthMessage, userAuthRequired, userAuthUrl, _callback);
        Type localVarReturnType = new TypeToken<ChatUnfurlResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UnfurlRequestBuilder {
        private final String token;
        private final String channel;
        private final String ts;
        private String unfurls;
        private String userAuthMessage;
        private Boolean userAuthRequired;
        private String userAuthUrl;

        private UnfurlRequestBuilder(String token, String channel, String ts) {
            this.token = token;
            this.channel = channel;
            this.ts = ts;
        }

        /**
         * Set unfurls
         * @param unfurls URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl blocks or message attachments. (optional)
         * @return UnfurlRequestBuilder
         */
        public UnfurlRequestBuilder unfurls(String unfurls) {
            this.unfurls = unfurls;
            return this;
        }
        
        /**
         * Set userAuthMessage
         * @param userAuthMessage Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior (optional)
         * @return UnfurlRequestBuilder
         */
        public UnfurlRequestBuilder userAuthMessage(String userAuthMessage) {
            this.userAuthMessage = userAuthMessage;
            return this;
        }
        
        /**
         * Set userAuthRequired
         * @param userAuthRequired Set to &#x60;true&#x60; or &#x60;1&#x60; to indicate the user must install your Slack app to trigger unfurls for this domain (optional)
         * @return UnfurlRequestBuilder
         */
        public UnfurlRequestBuilder userAuthRequired(Boolean userAuthRequired) {
            this.userAuthRequired = userAuthRequired;
            return this;
        }
        
        /**
         * Set userAuthUrl
         * @param userAuthUrl Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded. (optional)
         * @return UnfurlRequestBuilder
         */
        public UnfurlRequestBuilder userAuthUrl(String userAuthUrl) {
            this.userAuthUrl = userAuthUrl;
            return this;
        }
        
        /**
         * Build call for unfurl
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical, minimal success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ChatUnfurlRequest chatUnfurlRequest = buildBodyParams();
            return unfurlCall(token, channel, ts, chatUnfurlRequest, unfurls, userAuthMessage, userAuthRequired, userAuthUrl, _callback);
        }

        private ChatUnfurlRequest buildBodyParams() {
            ChatUnfurlRequest chatUnfurlRequest = new ChatUnfurlRequest();
            chatUnfurlRequest.channel(this.channel);
            chatUnfurlRequest.ts(this.ts);
            chatUnfurlRequest.unfurls(this.unfurls);
            chatUnfurlRequest.userAuthMessage(this.userAuthMessage);
            chatUnfurlRequest.userAuthRequired(this.userAuthRequired);
            chatUnfurlRequest.userAuthUrl(this.userAuthUrl);
            return chatUnfurlRequest;
        }

        /**
         * Execute unfurl request
         * @return ChatUnfurlResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical, minimal success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ChatUnfurlResponse execute() throws ApiException {
            ChatUnfurlRequest chatUnfurlRequest = buildBodyParams();
            ApiResponse<ChatUnfurlResponse> localVarResp = unfurlWithHttpInfo(token, channel, ts, chatUnfurlRequest, unfurls, userAuthMessage, userAuthRequired, userAuthUrl);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute unfurl request with HTTP info returned
         * @return ApiResponse&lt;ChatUnfurlResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical, minimal success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatUnfurlResponse> executeWithHttpInfo() throws ApiException {
            ChatUnfurlRequest chatUnfurlRequest = buildBodyParams();
            return unfurlWithHttpInfo(token, channel, ts, chatUnfurlRequest, unfurls, userAuthMessage, userAuthRequired, userAuthUrl);
        }

        /**
         * Execute unfurl request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical, minimal success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatUnfurlResponse> _callback) throws ApiException {
            ChatUnfurlRequest chatUnfurlRequest = buildBodyParams();
            return unfurlAsync(token, channel, ts, chatUnfurlRequest, unfurls, userAuthMessage, userAuthRequired, userAuthUrl, _callback);
        }
    }

    /**
     * 
     * Provide custom unfurl behavior for user-posted URLs
     * @param token Authentication token. Requires scope: &#x60;links:write&#x60; (required)
     * @param channel Channel ID of the message (required)
     * @param ts Timestamp of the message to add unfurl behavior to. (required)
     * @param chatUnfurlRequest  (required)
     * @return UnfurlRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical, minimal success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.unfurl"> Documentation</a>
     */
    public UnfurlRequestBuilder unfurl(String token, String channel, String ts) throws IllegalArgumentException {
        if (token == null) throw new IllegalArgumentException("\"token\" is required but got null");
            

        if (channel == null) throw new IllegalArgumentException("\"channel\" is required but got null");
            

        if (ts == null) throw new IllegalArgumentException("\"ts\" is required but got null");
            

        return new UnfurlRequestBuilder(token, channel, ts);
    }
    private okhttp3.Call updateCall(String token, String channel, String ts, String asUser, String attachments, String blocks, String linkNames, String parse, String text, ChatUpdateRequest chatUpdateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = chatUpdateRequest;

        // create path and map variables
        String localVarPath = "/chat.update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asUser != null) {
            localVarFormParams.put("as_user", asUser);
        }

        if (attachments != null) {
            localVarFormParams.put("attachments", attachments);
        }

        if (blocks != null) {
            localVarFormParams.put("blocks", blocks);
        }

        if (channel != null) {
            localVarFormParams.put("channel", channel);
        }

        if (linkNames != null) {
            localVarFormParams.put("link_names", linkNames);
        }

        if (parse != null) {
            localVarFormParams.put("parse", parse);
        }

        if (text != null) {
            localVarFormParams.put("text", text);
        }

        if (ts != null) {
            localVarFormParams.put("ts", ts);
        }

        if (token != null) {
            localVarHeaderParams.put("token", localVarApiClient.parameterToString(token));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "slackAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateValidateBeforeCall(String token, String channel, String ts, String asUser, String attachments, String blocks, String linkNames, String parse, String text, ChatUpdateRequest chatUpdateRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'token' is set
        if (token == null) {
            throw new ApiException("Missing the required parameter 'token' when calling update(Async)");
        }

        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling update(Async)");
        }

        // verify the required parameter 'ts' is set
        if (ts == null) {
            throw new ApiException("Missing the required parameter 'ts' when calling update(Async)");
        }

        return updateCall(token, channel, ts, asUser, attachments, blocks, linkNames, parse, text, chatUpdateRequest, _callback);

    }


    private ApiResponse<ChatUpdateResponse> updateWithHttpInfo(String token, String channel, String ts, String asUser, String attachments, String blocks, String linkNames, String parse, String text, ChatUpdateRequest chatUpdateRequest) throws ApiException {
        okhttp3.Call localVarCall = updateValidateBeforeCall(token, channel, ts, asUser, attachments, blocks, linkNames, parse, text, chatUpdateRequest, null);
        Type localVarReturnType = new TypeToken<ChatUpdateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call updateAsync(String token, String channel, String ts, String asUser, String attachments, String blocks, String linkNames, String parse, String text, ChatUpdateRequest chatUpdateRequest, final ApiCallback<ChatUpdateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateValidateBeforeCall(token, channel, ts, asUser, attachments, blocks, linkNames, parse, text, chatUpdateRequest, _callback);
        Type localVarReturnType = new TypeToken<ChatUpdateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class UpdateRequestBuilder {
        private final String token;
        private final String channel;
        private final String ts;
        private String asUser;
        private String attachments;
        private String blocks;
        private String linkNames;
        private String parse;
        private String text;

        private UpdateRequestBuilder(String token, String channel, String ts) {
            this.token = token;
            this.channel = channel;
            this.ts = ts;
        }

        /**
         * Set asUser
         * @param asUser Pass true to update the message as the authed user. [Bot users](https://slack.dev) in this context are considered authed users. (optional)
         * @return UpdateRequestBuilder
         */
        public UpdateRequestBuilder asUser(String asUser) {
            this.asUser = asUser;
            return this;
        }
        
        /**
         * Set attachments
         * @param attachments A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting &#x60;text&#x60;. If you don&#39;t include this field, the message&#39;s previous &#x60;attachments&#x60; will be retained. To remove previous &#x60;attachments&#x60;, include an empty array for this field. (optional)
         * @return UpdateRequestBuilder
         */
        public UpdateRequestBuilder attachments(String attachments) {
            this.attachments = attachments;
            return this;
        }
        
        /**
         * Set blocks
         * @param blocks A JSON-based array of [structured blocks](https://slack.dev), presented as a URL-encoded string. If you don&#39;t include this field, the message&#39;s previous &#x60;blocks&#x60; will be retained. To remove previous &#x60;blocks&#x60;, include an empty array for this field. (optional)
         * @return UpdateRequestBuilder
         */
        public UpdateRequestBuilder blocks(String blocks) {
            this.blocks = blocks;
            return this;
        }
        
        /**
         * Set linkNames
         * @param linkNames Find and link channel names and usernames. Defaults to &#x60;none&#x60;. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, &#x60;none&#x60;. (optional)
         * @return UpdateRequestBuilder
         */
        public UpdateRequestBuilder linkNames(String linkNames) {
            this.linkNames = linkNames;
            return this;
        }
        
        /**
         * Set parse
         * @param parse Change how messages are treated. Defaults to &#x60;client&#x60;, unlike &#x60;chat.postMessage&#x60;. Accepts either &#x60;none&#x60; or &#x60;full&#x60;. If you do not specify a value for this field, the original value set for the message will be overwritten with the default, &#x60;client&#x60;. (optional)
         * @return UpdateRequestBuilder
         */
        public UpdateRequestBuilder parse(String parse) {
            this.parse = parse;
            return this;
        }
        
        /**
         * Set text
         * @param text New text for the message, using the [default formatting rules](https://slack.dev). It&#39;s not required when presenting &#x60;blocks&#x60; or &#x60;attachments&#x60;. (optional)
         * @return UpdateRequestBuilder
         */
        public UpdateRequestBuilder text(String text) {
            this.text = text;
            return this;
        }
        
        /**
         * Build call for update
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            ChatUpdateRequest chatUpdateRequest = buildBodyParams();
            return updateCall(token, channel, ts, asUser, attachments, blocks, linkNames, parse, text, chatUpdateRequest, _callback);
        }

        private ChatUpdateRequest buildBodyParams() {
            ChatUpdateRequest chatUpdateRequest = new ChatUpdateRequest();
            chatUpdateRequest.asUser(this.asUser);
            chatUpdateRequest.attachments(this.attachments);
            chatUpdateRequest.blocks(this.blocks);
            chatUpdateRequest.channel(this.channel);
            chatUpdateRequest.linkNames(this.linkNames);
            chatUpdateRequest.parse(this.parse);
            chatUpdateRequest.text(this.text);
            chatUpdateRequest.ts(this.ts);
            return chatUpdateRequest;
        }

        /**
         * Execute update request
         * @return ChatUpdateResponse
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ChatUpdateResponse execute() throws ApiException {
            ChatUpdateRequest chatUpdateRequest = buildBodyParams();
            ApiResponse<ChatUpdateResponse> localVarResp = updateWithHttpInfo(token, channel, ts, asUser, attachments, blocks, linkNames, parse, text, chatUpdateRequest);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute update request with HTTP info returned
         * @return ApiResponse&lt;ChatUpdateResponse&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<ChatUpdateResponse> executeWithHttpInfo() throws ApiException {
            ChatUpdateRequest chatUpdateRequest = buildBodyParams();
            return updateWithHttpInfo(token, channel, ts, asUser, attachments, blocks, linkNames, parse, text, chatUpdateRequest);
        }

        /**
         * Execute update request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<ChatUpdateResponse> _callback) throws ApiException {
            ChatUpdateRequest chatUpdateRequest = buildBodyParams();
            return updateAsync(token, channel, ts, asUser, attachments, blocks, linkNames, parse, text, chatUpdateRequest, _callback);
        }
    }

    /**
     * 
     * Updates a message.
     * @param token Authentication token. Requires scope: &#x60;chat:write&#x60; (required)
     * @param channel Channel containing the message to be updated. (required)
     * @param ts Timestamp of the message to be updated. (required)
     * @return UpdateRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Typical success response </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> Typical error response </td><td>  -  </td></tr>
     </table>
     * API method documentation
     * @see <a href="https://api.slack.com/methods/chat.update"> Documentation</a>
     */
    public UpdateRequestBuilder update(String token, String channel, String ts) throws IllegalArgumentException {
        if (token == null) throw new IllegalArgumentException("\"token\" is required but got null");
            

        if (channel == null) throw new IllegalArgumentException("\"channel\" is required but got null");
            

        if (ts == null) throw new IllegalArgumentException("\"ts\" is required but got null");
            

        return new UpdateRequestBuilder(token, channel, ts);
    }
}
